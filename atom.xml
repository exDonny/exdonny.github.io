<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐仁鑫</title>
  
  <subtitle>不是在编程就是在编程的路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.rxdonny.com/"/>
  <updated>2018-06-30T05:36:41.282Z</updated>
  <id>http://www.rxdonny.com/</id>
  
  <author>
    <name>认金</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JQuery Ajax的标准写法</title>
    <link href="http://www.rxdonny.com/2018/06/30/JQuery%20Ajax%E7%9A%84%E6%A0%87%E5%87%86%E5%86%99%E6%B3%95/"/>
    <id>http://www.rxdonny.com/2018/06/30/JQuery Ajax的标准写法/</id>
    <published>2018-06-30T05:30:51.000Z</published>
    <updated>2018-06-30T05:36:41.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JQuery-Ajax的标准写法"><a href="#JQuery-Ajax的标准写法" class="headerlink" title="JQuery Ajax的标准写法"></a>JQuery Ajax的标准写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"xxxx"</span>,            <span class="comment">//请求的url地址</span></span><br><span class="line">    dataType:<span class="string">"json"</span>,       <span class="comment">//返回的格式为json</span></span><br><span class="line">    async:<span class="keyword">true</span>,            <span class="comment">//请求是否异步，默认true异步</span></span><br><span class="line">    data:&#123;key1:value1,key2:value2&#125;,<span class="comment">//参数值</span></span><br><span class="line">    type:<span class="string">"GET"</span>,             <span class="comment">//请求的方式</span></span><br><span class="line">    beforeSend:function()&#123;&#125;,<span class="comment">//请求前的处理</span></span><br><span class="line">    success:function(req)&#123;&#125;,<span class="comment">//请求成功的处理</span></span><br><span class="line">    complete:function()&#123;&#125;,  <span class="comment">//请求完成的处理</span></span><br><span class="line">    error:function()&#123;&#125;      <span class="comment">//请求出错的处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JQuery-Ajax的标准写法&quot;&gt;&lt;a href=&quot;#JQuery-Ajax的标准写法&quot; class=&quot;headerlink&quot; title=&quot;JQuery Ajax的标准写法&quot;&gt;&lt;/a&gt;JQuery Ajax的标准写法&lt;/h2&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Ajax" scheme="http://www.rxdonny.com/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://www.rxdonny.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>代理模式--JDK动态代理的原理及实现</title>
    <link href="http://www.rxdonny.com/2018/06/01/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://www.rxdonny.com/2018/06/01/JDK动态代理/</id>
    <published>2018-06-01T09:07:24.000Z</published>
    <updated>2018-06-01T11:21:38.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h2><p>来自于菜鸟教程的解释：<br>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决</strong>：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用</strong>：想在访问一个类时做一些控制。</p><p><strong>如何解决</strong>：增加中间层。</p><p><strong>关键代码</strong>：实现与被代理类组合。</p><p><strong>应用实例</strong>： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p><p><strong>优点</strong>： 1、职责清晰。 2、高扩展性。 3、智能化。</p><p><strong>缺点</strong>： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><p><strong>使用场景</strong>：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p><p><strong>注意事项</strong>： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 </p><h2 id="代理模式的实现步骤"><a href="#代理模式的实现步骤" class="headerlink" title="代理模式的实现步骤"></a>代理模式的实现步骤</h2><p>在使用代理模式时，我们需要在调用者代用对象之前生成一个代理对象，而这个代理对象需要跟真实对象建立代理关系，所以代理必须分为两步：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> 代理对象和真实对象建立关系。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> 实现代理对象的代理逻辑方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在java中有很多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的有两种：一种是JDK动态代理，这是JDK自带的功能；另一种是CGLIB，这是第三方提供的一个技术。<strong>在JDK动态代理中，我们需要使用接口，而CGLIB不用</strong>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK动态代理是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象，所以我们先定义一个接口HelloWord：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWord</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后提供实现类HelloWordImpl来实现接口HelloWord：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWordImpl</span> <span class="keyword">implements</span> <span class="title">HelloWord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello Word!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时我们要建立一个实现代理逻辑类JdkProxyExample；按照我们之前的描述，实现动态代理<strong>先要建立起代理对象和真实服务对象的关系，然后实现代理逻辑</strong>；在JDK动态代理中，要实现代理逻辑类必须去实现java.lang.reflect.InvocationHandler接口，它里面定义了一个invoke方法，并提供接口数组用于下挂代理对象（测试时使用了JUnit4）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="comment">//  真实对象</span></span><br><span class="line"><span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//第一步：建立代理对象和真实对象的代理关系，并返回代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//   此时的 target是一个真实的对象  ，通过真实对象返回一个代理对象</span></span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一个参数：是类加载器</span></span><br><span class="line"><span class="comment"> * 第二个参数：将生成的代理的对象下挂在哪些接口下</span></span><br><span class="line"><span class="comment"> * 第三个参数：定义实现方法逻辑的代理类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  第二步：实现代理逻辑方法</span></span><br><span class="line"><span class="comment">//  实现java.lang.reflect.InvocationHandler接口的invoke方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进入代理逻辑方法"</span>);</span><br><span class="line">System.out.println(<span class="string">"在调度真实对象之前的服务"</span>);</span><br><span class="line">Object object = method.invoke(target, args);<span class="comment">//  相当于调用了sayHelloWord();</span></span><br><span class="line">System.out.println(<span class="string">"在调度真实对象之后的服务"</span>);</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdkProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">JdkProxyExample jdk = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line"><span class="comment">// 绑定关系，因为是挂在接口HelloWord下，所以声明HelloWord proxy</span></span><br><span class="line">HelloWord proxy = (HelloWord) jdk.bind(<span class="keyword">new</span> HelloWordImpl());</span><br><span class="line"><span class="comment">//  此时proxy对象已经是一个代理对象，当它调用方法时会进入代理的逻辑方法invoke（）中</span></span><br><span class="line">proxy.sayHelloWord();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第一步：建立代理对象和真实对象的关系</strong>。这里是使用了bind方法完成，方法里首先用类的属性target保存了真实对象，然后通过下面的代码建立并返回代理对象：<br>Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);<br>其中newProxyInstance方法包含了3个参数。</p><ul><li>第1个是类加载器，我们使用target自身的加载器；</li><li>第2个是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在target实现的接口下。即HelloWord接口</li><li>第3个是定义<strong>实现代理逻辑方法的实现类</strong>，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，<strong>它就是代理逻辑方法的实现方法</strong>。</li></ul><p><strong>第二步：实现代理逻辑方法</strong>。invoke方法的3个参数：</p><ul><li>proxy，代理对象，就是bind方法生成的对象（返回的对象）。</li><li>method，当前调度的方法。</li><li>args，调度方法的参数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用了代理对象调度方法后，它就会进入到invoke方法里面<br>测试结果：</li></ul><hr><p>进入代理逻辑方法<br>在调度真实对象之前的服务<br>Hello Word!<br>在调度真实对象之后的服务</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是代理模式&quot;&gt;&lt;a href=&quot;#什么是代理模式&quot; class=&quot;headerlink&quot; title=&quot;什么是代理模式&quot;&gt;&lt;/a&gt;什么是代理模式&lt;/h2&gt;&lt;p&gt;来自于菜鸟教程的解释：&lt;br&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。
      
    
    </summary>
    
      <category term="设计模式" scheme="http://www.rxdonny.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.rxdonny.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JUnit单元测试框架</title>
    <link href="http://www.rxdonny.com/2018/05/27/JUnit/"/>
    <id>http://www.rxdonny.com/2018/05/27/JUnit/</id>
    <published>2018-05-27T15:27:24.000Z</published>
    <updated>2018-05-29T08:25:11.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JUnit的运行流程"><a href="#JUnit的运行流程" class="headerlink" title="JUnit的运行流程"></a>JUnit的运行流程</h3><p>在myeclipse中创建一个JUnit test case依次选中下面四个方法<br><img src="1.png" alt="1"><br>生成并修改为如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.AfterClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpBeforeClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"This is BeforeClass ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AfterClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tearDownAfterClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"This is AfterClass ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"This is Before ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"This is After ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"This is test1 ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"This is test2 ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">This is BeforeClass ...</span><br><span class="line">This is Before ...</span><br><span class="line">This is test1 ...</span><br><span class="line">This is After ...</span><br><span class="line">This is Before ...</span><br><span class="line">This is test2 ...</span><br><span class="line">This is After ...</span><br><span class="line">This is AfterClass ...</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.@BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法是静态的，所以放测试类被加载后接着就会运行它，它在内存中只会存在一份实例，比较适合加载配置文件或只被执行一次的文件。<br>2.@AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库连接。<br>3.@Before和@After会在每个测试方法的前后各执行一次。</p><h3 id="JUnit的常用注解"><a href="#JUnit的常用注解" class="headerlink" title="JUnit的常用注解"></a>JUnit的常用注解</h3><p>除了上上面的五种注解外还介绍下面几种：<br>1.@Ignore ：所修饰的方法会被测试运行器忽略<br>2.@RunWith：可以更改测试运行器（如测试套件的使用）<br><img src="2.png" alt="测试套件"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JUnit的运行流程&quot;&gt;&lt;a href=&quot;#JUnit的运行流程&quot; class=&quot;headerlink&quot; title=&quot;JUnit的运行流程&quot;&gt;&lt;/a&gt;JUnit的运行流程&lt;/h3&gt;&lt;p&gt;在myeclipse中创建一个JUnit test case依次选中下面四个
      
    
    </summary>
    
      <category term="Junit" scheme="http://www.rxdonny.com/categories/Junit/"/>
    
    
      <category term="Junit" scheme="http://www.rxdonny.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>linux安装jdk出现 bad ELF interpreter 没有那个文件或目录</title>
    <link href="http://www.rxdonny.com/2018/05/17/linux%E5%AE%89%E8%A3%85jdk%E5%90%8E%E5%87%BA%E7%8E%B0bad%20ELF%20interpreter%20%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/"/>
    <id>http://www.rxdonny.com/2018/05/17/linux安装jdk后出现bad ELF interpreter 没有那个文件或目录/</id>
    <published>2018-05-17T03:27:24.000Z</published>
    <updated>2018-05-17T03:50:52.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录在项目中遇到的问题"><a href="#记录在项目中遇到的问题" class="headerlink" title="记录在项目中遇到的问题"></a>记录在项目中遇到的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>配置完环境变量后用java -version测试出现“bash: ./java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录”，网上搜了下，用sudo yum install glibc.i686命令安装好glibc之后就ok。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录在项目中遇到的问题&quot;&gt;&lt;a href=&quot;#记录在项目中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;记录在项目中遇到的问题&quot;&gt;&lt;/a&gt;记录在项目中遇到的问题&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbs
      
    
    </summary>
    
      <category term="linux" scheme="http://www.rxdonny.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.rxdonny.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>前端js阻止事件冒泡</title>
    <link href="http://www.rxdonny.com/2018/04/21/%E5%89%8D%E7%AB%AFjs%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    <id>http://www.rxdonny.com/2018/04/21/前端js阻止事件冒泡/</id>
    <published>2018-04-21T12:27:24.000Z</published>
    <updated>2018-04-21T12:40:13.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录在项目中遇到的问题"><a href="#记录在项目中遇到的问题" class="headerlink" title="记录在项目中遇到的问题"></a>记录在项目中遇到的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>1.event.stopPropagation()方法</p><p>这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开，</p><p>2.event.preventDefault()方法</p><p>这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-table-view"</span>&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-table-view-cell mui-media"</span> onclick=<span class="string">"ligo(this,1)"</span> style=<span class="string">"color: blue;"</span>&gt;</span><br><span class="line">&lt;span&gt;飞速洗车&lt;/span&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-btn mui-btn-primary"</span>style=<span class="string">"float: right;"</span> onclick=<span class="string">"btngo(this,5)"</span>&gt;</span><br><span class="line">立即预约</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-table-view-cell mui-media"</span> onclick=<span class="string">"ligo(this,1)"</span> style=<span class="string">"color: blue;"</span>&gt;</span><br><span class="line">&lt;span&gt;换机油&lt;/span&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-btn mui-btn-primary"</span>style=<span class="string">"float: right;"</span> onclick=<span class="string">"btngo(this,5)"</span>&gt;</span><br><span class="line">立即预约</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-table-view-cell mui-media"</span> onclick=<span class="string">"ligo(this,1)"</span> style=<span class="string">"color: blue;"</span>&gt;</span><br><span class="line">&lt;span&gt;来了来了&lt;/span&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"mui-btn mui-btn-primary"</span>style=<span class="string">"float: right;"</span> onclick=<span class="string">"btngo(this,5)"</span>&gt;</span><br><span class="line">立即预约</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">ligo</span><span class="params">(a,sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//   跳转服务详情界面</span></span><br><span class="line">alert(a.tagName+<span class="string">"\t"</span>+sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">btngo</span><span class="params">(a,sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  跳转预约界面</span></span><br><span class="line">event.stopPropagation();<span class="comment">//  阻止冒泡</span></span><br><span class="line">alert(a.tagName+<span class="string">"\t"</span>+sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录在项目中遇到的问题&quot;&gt;&lt;a href=&quot;#记录在项目中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;记录在项目中遇到的问题&quot;&gt;&lt;/a&gt;记录在项目中遇到的问题&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbs
      
    
    </summary>
    
      <category term="js" scheme="http://www.rxdonny.com/categories/js/"/>
    
    
      <category term="js" scheme="http://www.rxdonny.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Timestamp类型时间加一天、一个月、一年...</title>
    <link href="http://www.rxdonny.com/2018/04/19/timestamp%E7%B1%BB%E5%9E%8B%E6%97%B6%E9%97%B4%E7%9A%84%E5%8A%A0%E5%87%8F/"/>
    <id>http://www.rxdonny.com/2018/04/19/timestamp类型时间的加减/</id>
    <published>2018-04-19T12:17:24.000Z</published>
    <updated>2018-04-19T12:45:31.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录在项目中遇到的问题"><a href="#记录在项目中遇到的问题" class="headerlink" title="记录在项目中遇到的问题"></a>记录在项目中遇到的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景：mysql数据库中有张user表，表中有一个overdue字段，字段类型为Timestamp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Do what：java中根据用户ID将该用户的overdue取出，加一年后修改user表中的overdue。</p><h2 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h2><h3 id="方法一：暴力…"><a href="#方法一：暴力…" class="headerlink" title="方法一：暴力…"></a>方法一：暴力…</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">timestample</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">Timestamp timestamp  = <span class="keyword">new</span> Timestamp(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//  将Timestamp 转换成long类型进行加减再转换成Timestamp</span></span><br><span class="line"><span class="comment">//加一天</span></span><br><span class="line"><span class="keyword">long</span> time=timestamp.getTime()+(<span class="keyword">long</span>)<span class="number">1000</span>*<span class="number">3600</span>*<span class="number">24</span>;     </span><br><span class="line"><span class="comment">//加一个月   注：一个月按30天算</span></span><br><span class="line"><span class="keyword">long</span> time3 =timestamp.getTime()+(<span class="keyword">long</span>)<span class="number">1000</span>*<span class="number">3600</span>*<span class="number">24</span>*<span class="number">30</span>;</span><br><span class="line"><span class="comment">//加一年</span></span><br><span class="line"><span class="keyword">long</span> time4 =timestamp.getTime()+(<span class="keyword">long</span>)<span class="number">1000</span>*<span class="number">3600</span>*<span class="number">24</span>*<span class="number">365</span>;</span><br><span class="line"></span><br><span class="line">Timestamp timestamp2 =<span class="keyword">new</span> Timestamp(time);</span><br><span class="line">Timestamp timestamp3 =<span class="keyword">new</span> Timestamp(time3);</span><br><span class="line">Timestamp timestamp4 =<span class="keyword">new</span> Timestamp(time4);</span><br><span class="line"><span class="comment">//  转回Timestamp</span></span><br><span class="line">System.out.println(<span class="string">"当前时间："</span>+timestamp);</span><br><span class="line">System.out.println(<span class="string">"加上一天："</span>+timestamp2);</span><br><span class="line">System.out.println(<span class="string">"加一个月："</span>+timestamp3);</span><br><span class="line">System.out.println(<span class="string">"加上一年："</span>+timestamp4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="1.png" alt="1图"></p><h3 id="方法一：我转…"><a href="#方法一：我转…" class="headerlink" title="方法一：我转…"></a>方法一：我转…</h3><p>使用Calendar类<br>1、java中将overdue取出，用TimeStamp 类型的变量接收timestamp；<br>2、实例化一个Calendar类的实例<br>3、将timestamp转换为Calendar<br>4、进行加减操作<br>5、转回TimeStamp 类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">timestample</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">Timestamp timestamp0  = <span class="keyword">new</span> Timestamp(System.currentTimeMillis());</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.setTime(timestamp0);</span><br><span class="line">  <span class="comment">//c.add(Calendar.DATE, 1);  //  加一  天</span></span><br><span class="line">  <span class="comment">//c.add(Calendar.MONTH, 1); //  加一个月</span></span><br><span class="line">c.add(Calendar.YEAR,<span class="number">1</span>);   <span class="comment">//  加一  年</span></span><br><span class="line">Timestamp time1 = <span class="keyword">new</span> Timestamp(c.getTimeInMillis());</span><br><span class="line">System.out.println(time1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录在项目中遇到的问题&quot;&gt;&lt;a href=&quot;#记录在项目中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;记录在项目中遇到的问题&quot;&gt;&lt;/a&gt;记录在项目中遇到的问题&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbs
      
    
    </summary>
    
      <category term="Timestamp" scheme="http://www.rxdonny.com/categories/Timestamp/"/>
    
    
      <category term="Timestamp" scheme="http://www.rxdonny.com/tags/Timestamp/"/>
    
  </entry>
  
  <entry>
    <title>spring中&lt;contextcomponent-scan&gt;的简单使用</title>
    <link href="http://www.rxdonny.com/2018/04/19/spring%E4%B8%ADcontextcomponent-scan%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%20/"/>
    <id>http://www.rxdonny.com/2018/04/19/spring中contextcomponent-scan的简单使用 /</id>
    <published>2018-04-19T02:47:24.000Z</published>
    <updated>2018-04-19T02:54:44.078Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用spring进行开发时，我们常常会配置<context:component-scan></context:component-scan>标签。<br>如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:util=<span class="string">"http://www.springframework.org/schema/util"</span></span><br><span class="line">xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span> xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context </span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span><br><span class="line">&lt;!-- 扫描 --&gt;</span><br><span class="line">&lt;context:component-scan base-package="com.action"&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>配置完成后，spring就会去自动扫描base-package对应的路径或者该路径的子包下面的java文件（如：com.action包下的所有类），如果扫描到文件中带有@Service,@Component,@Repository,@Controller等这些注解的类，则把这些类注册为bean，就不需要开发人员再去applicationContext.xml中手动配置com.action包中的类的bean以及一些依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在使用spring进行开发时，我们常常会配置&lt;context:component-scan&gt;&lt;/context:component-scan&gt;标签。&lt;br&gt;如:&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="spring" scheme="http://www.rxdonny.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.rxdonny.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis事务</title>
    <link href="http://www.rxdonny.com/2018/04/12/redis--%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.rxdonny.com/2018/04/12/redis--事务/</id>
    <published>2018-04-12T10:47:24.000Z</published>
    <updated>2018-04-13T10:07:15.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：<br> 1). 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。<br>2). 和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。<br>3). 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。<br>4). 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。<br>5). 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p><h3 id="二、相关命令（O表示时间复杂度）"><a href="#二、相关命令（O表示时间复杂度）" class="headerlink" title="二、相关命令（O表示时间复杂度）"></a>二、相关命令（O表示时间复杂度）</h3><h5 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h5><p>用于标记事务的开始，其后执行的命令都将被存入命令队列，直到执行EXEC时，这些命令才会被原子的执行。    始终返回OK</p><h5 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h5><p>执行在一个事务内命令队列中的所有命令，同时将当前连接的状态恢复为正常状态，即非事务状态。如果在事务中执行了WATCH命令，那么只有当WATCH所监控的Keys没有被修改的前提下，EXEC命令才能执行事务队列中的所有命令，否则EXEC将放弃当前事务中的所有命令。    原子性的返回事务中各条命令的返回结果。如果在事务中使用了WATCH，一旦事务被放弃，EXEC将返回NULL-multi-bulk回复。</p><h5 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h5><p>回滚事务队列中的所有命令，同时再将当前连接的状态恢复为正常状态，即非事务状态。如果WATCH命令被使用，该命令将UNWATCH所有的Keys。    始终返回OK。</p><h5 id="WATCH-key-key-…-O-1"><a href="#WATCH-key-key-…-O-1" class="headerlink" title="WATCH key [key …]    O(1)"></a>WATCH key [key …]    O(1)</h5><p>在MULTI命令执行之前，可以指定待监控的Keys，然而在执行EXEC之前，如果被监控的Keys发生修改，EXEC将放弃执行该事务队列中的所有命令。    始终返回OK。</p><h5 id="UNWATCH-O-1"><a href="#UNWATCH-O-1" class="headerlink" title="UNWATCH    O(1)"></a>UNWATCH    O(1)</h5><p>取消当前事务中指定监控的Keys，如果执行了EXEC或DISCARD命令，则无需再手工执行该命令了，因为在此之后，事务中所有被监控的Keys都将自动取消。    始终返回OK。</p><h3 id="三、命令示例："><a href="#三、命令示例：" class="headerlink" title="三、命令示例："></a>三、命令示例：</h3><h5 id="1-事务被正常执行："><a href="#1-事务被正常执行：" class="headerlink" title="1. 事务被正常执行："></a>1. 事务被正常执行：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行下执行Redis的客户端工具。</span><br><span class="line"> /&gt; redis-cli</span><br><span class="line"> #在当前连接上启动一个新的事务。</span><br><span class="line"> redis 127.0.0.1:6379&gt; multi</span><br><span class="line"> OK</span><br><span class="line"> #执行事务中的第一条命令，从该命令的返回结果可以看出，该命令并没有立即执行，而是存于事务的命令队列。</span><br><span class="line"> redis 127.0.0.1:6379&gt; incr t1</span><br><span class="line"> QUEUED</span><br><span class="line"> #又执行一个新的命令，从结果可以看出，该命令也被存于事务的命令队列。</span><br><span class="line"> redis 127.0.0.1:6379&gt; incr t2</span><br><span class="line"> QUEUED</span><br><span class="line"> #执行事务命令队列中的所有命令，从结果可以看出，队列中命令的结果得到返回。</span><br><span class="line"> redis 127.0.0.1:6379&gt; exec</span><br><span class="line"> 1) (integer) 1</span><br><span class="line"> 2) (integer) 1</span><br></pre></td></tr></table></figure><h5 id="2-事务中存在失败的命令："><a href="#2-事务中存在失败的命令：" class="headerlink" title="2. 事务中存在失败的命令："></a>2. 事务中存在失败的命令：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#开启一个新的事务。</span><br><span class="line">redis 127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">#设置键a的值为string类型的3。</span><br><span class="line">redis 127.0.0.1:6379&gt; set a 3</span><br><span class="line">QUEUED</span><br><span class="line">#从键a所关联的值的头部弹出元素，由于该值是字符串类型，而lpop命令仅能用于List类型，因此在执行exec命令时，该命令将会失败。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop a</span><br><span class="line">QUEUED</span><br><span class="line">#再次设置键a的值为字符串4。</span><br><span class="line">redis 127.0.0.1:6379&gt; set a 4</span><br><span class="line">QUEUED</span><br><span class="line">#获取键a的值，以便确认该值是否被事务中的第二个set命令设置成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">#从结果中可以看出，事务中的第二条命令lpop执行失败，而其后的set和get命令均执行成功，这一点是Redis的事务与关系型数据库中的事务之间最为重要的差别。</span><br><span class="line">redis 127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR Operation against a key holding the wrong kind of value</span><br><span class="line">3) OK</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h5 id="3-回滚事务："><a href="#3-回滚事务：" class="headerlink" title="3.回滚事务："></a>3.回滚事务：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> #为键t2设置一个事务执行前的值。</span><br><span class="line">redis 127.0.0.1:6379&gt; set t2 tt</span><br><span class="line">OK</span><br><span class="line">#开启一个事务。</span><br><span class="line">redis 127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">#在事务内为该键设置一个新值。</span><br><span class="line">redis 127.0.0.1:6379&gt; set t2 ttnew</span><br><span class="line">QUEUED</span><br><span class="line">#放弃事务。</span><br><span class="line">redis 127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">#查看键t2的值，从结果中可以看出该键的值仍为事务开始之前的值。</span><br><span class="line">redis 127.0.0.1:6379&gt; get t2</span><br><span class="line">&quot;tt&quot;</span><br></pre></td></tr></table></figure><h3 id="四、WATCH命令和基于CAS的乐观锁："><a href="#四、WATCH命令和基于CAS的乐观锁：" class="headerlink" title="四、WATCH命令和基于CAS的乐观锁："></a>四、WATCH命令和基于CAS的乐观锁：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：<br>val = GET mykey<br>val = val + 1<br>SET mykey $val<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景–竞态争用(race condition)。比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：<br>WATCH mykey<br>val = GET mykey<br>val = val + 1<br>MULTI<br>SET mykey $val<br>EXEC<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述：&quot;&gt;&lt;a href=&quot;#一、概述：&quot; class=&quot;headerlink&quot; title=&quot;一、概述：&quot;&gt;&lt;/a&gt;一、概述：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;和众多其它数据库一样，Redis
      
    
    </summary>
    
      <category term="redis笔记" scheme="http://www.rxdonny.com/categories/redis%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://www.rxdonny.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据类型-Sorted-Sets</title>
    <link href="http://www.rxdonny.com/2018/04/12/redis--Sorted-Sets%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.rxdonny.com/2018/04/12/redis--Sorted-Sets类型/</id>
    <published>2018-04-12T08:57:24.000Z</published>
    <updated>2018-04-13T09:33:34.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p><h3 id="二、相关命令（O表示时间复杂度）"><a href="#二、相关命令（O表示时间复杂度）" class="headerlink" title="二、相关命令（O表示时间复杂度）"></a>二、相关命令（O表示时间复杂度）</h3><h5 id="ZADD-key-score-member-score-member-O-log-N"><a href="#ZADD-key-score-member-score-member-O-log-N" class="headerlink" title="ZADD key score member [score] [member]     O(log(N))"></a>ZADD key score member [score] [member]     O(log(N))</h5><p>时间复杂度中的N表示Sorted-Sets中成员的数量。添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。如果该键已经存在，但是与其关联的Value不是Sorted-Sets类型，相关的错误信息将被返回。    本次操作实际插入的成员数量。</p><h5 id="ZCARD-key-O-1"><a href="#ZCARD-key-O-1" class="headerlink" title="ZCARD key     O(1)"></a>ZCARD key     O(1)</h5><p>获取与该Key相关联的Sorted-Sets中包含的成员数量。    返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</p><h5 id="ZCOUNT-key-min-max-O-log-N-M"><a href="#ZCOUNT-key-min-max-O-log-N-M" class="headerlink" title="ZCOUNT key min max    O(log(N)+M)"></a>ZCOUNT key min max    O(log(N)+M)</h5><p>该命令用于获取分数(score)在min和max之间的成员数量。针对min和max参数需要额外说明的是，-inf和+inf分别表示Sorted-Sets中分数的最高值和最低值。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。    分数指定范围内成员的数量。</p><h5 id="ZINCRBY-key-increment-member-O-log-N"><a href="#ZINCRBY-key-increment-member-O-log-N" class="headerlink" title="ZINCRBY key increment member     O(log(N))"></a>ZINCRBY key increment member     O(log(N))</h5><p>该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。如果与该Key关联的不是Sorted-Sets类型，相关的错误信息将被返回。    以字符串形式表示的新分数。</p><h5 id="ZRANGE-key-start-stop-WITHSCORES-O-log-N-M"><a href="#ZRANGE-key-start-stop-WITHSCORES-O-log-N-M" class="headerlink" title="ZRANGE key start stop [WITHSCORES]     O(log(N)+M)"></a>ZRANGE key start stop [WITHSCORES]     O(log(N)+M)</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令返回顺序在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。　　    返回索引在start和stop之间的成员列表。</p><h5 id="ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count-O-log-N-M"><a href="#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count-O-log-N-M" class="headerlink" title="ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]     O(log(N)+M)"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]     O(log(N)+M)</h5><p>该命令将返回分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。可选参数WITHSCORES的含义参照ZRANGE中该选项的说明。最后需要说明的是参数中min和max的规则可参照命令ZCOUNT。    返回分数在指定范围内的成员列表。</p><h5 id="ZRANK-key-member-O-log-N"><a href="#ZRANK-key-member-O-log-N" class="headerlink" title="ZRANK key member     O(log(N))"></a>ZRANK key member     O(log(N))</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量。Sorted-Set中的成员都是按照分数从低到高的顺序存储，该命令将返回参数中指定成员的位置值，其中0表示第一个成员，它是Sorted-Set中分数最低的成员。    如果该成员存在，则返回它的位置索引值。否则返回nil。</p><h5 id="ZREM-key-member-member-…-O-M-log-N"><a href="#ZREM-key-member-member-…-O-M-log-N" class="headerlink" title="ZREM key member [member …]    O(M log(N))"></a>ZREM key member [member …]    O(M log(N))</h5><p>时间复杂度中N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。    实际被删除的成员数量。</p><h5 id="ZREVRANGE-key-start-stop-WITHSCORES-O-log-N-M"><a href="#ZREVRANGE-key-start-stop-WITHSCORES-O-log-N-M" class="headerlink" title="ZREVRANGE key start stop [WITHSCORES]      O(log(N)+M)"></a>ZREVRANGE key start stop [WITHSCORES]      O(log(N)+M)</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令的功能和ZRANGE基本相同，唯一的差别在于该命令是通过反向排序获取指定位置的成员，即从高到低的顺序。如果成员具有相同的分数，则按降序字典顺序排序。    返回指定的成员列表。</p><h5 id="ZREVRANK-key-member-O-log-N"><a href="#ZREVRANK-key-member-O-log-N" class="headerlink" title="ZREVRANK key member     O(log(N))"></a>ZREVRANK key member     O(log(N))</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量。该命令的功能和ZRANK基本相同，唯一的差别在于该命令获取的索引是从高到低排序后的位置，同样0表示第一个元素，即分数最高的成员。    如果该成员存在，则返回它的位置索引值。否则返回nil。 </p><h5 id="ZSCORE-key-member-O-1"><a href="#ZSCORE-key-member-O-1" class="headerlink" title="ZSCORE key member    O(1)"></a>ZSCORE key member    O(1)</h5><p>获取指定Key的指定成员的分数。    如果该成员存在，以字符串的形式返回其分数，否则返回nil。</p><h5 id="ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count-O-log-N-M"><a href="#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count-O-log-N-M" class="headerlink" title="ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]     O(log(N)+M)"></a>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]     O(log(N)+M)</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。    返回分数在指定范围内的成员列表。 </p><h5 id="ZREMRANGEBYRANK-key-start-stop-O-log-N-M"><a href="#ZREMRANGEBYRANK-key-start-stop-O-log-N-M" class="headerlink" title="ZREMRANGEBYRANK key start stop     O(log(N)+M)"></a>ZREMRANGEBYRANK key start stop     O(log(N)+M)</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。      被删除的成员数量。</p><h5 id="ZREMRANGEBYSCORE-key-min-max-O-log-N-M"><a href="#ZREMRANGEBYSCORE-key-min-max-O-log-N-M" class="headerlink" title="ZREMRANGEBYSCORE key min max     O(log(N)+M)"></a>ZREMRANGEBYSCORE key min max     O(log(N)+M)</h5><p>时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。     被删除的成员数量。</p><h3 id="三、命令示例："><a href="#三、命令示例：" class="headerlink" title="三、命令示例："></a>三、命令示例：</h3><h5 id="1-ZADD-ZCARD-ZCOUNT-ZREM-ZINCRBY-ZSCORE-ZRANGE-ZRANK"><a href="#1-ZADD-ZCARD-ZCOUNT-ZREM-ZINCRBY-ZSCORE-ZRANGE-ZRANK" class="headerlink" title="1. ZADD/ZCARD/ZCOUNT/ZREM/ZINCRBY/ZSCORE/ZRANGE/ZRANK:"></a>1. ZADD/ZCARD/ZCOUNT/ZREM/ZINCRBY/ZSCORE/ZRANGE/ZRANK:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#在Shell的命令行下启动Redis客户端工具。</span><br><span class="line">  /&gt; redis-cli</span><br><span class="line">  #添加一个分数为1的成员。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot;</span><br><span class="line">  (integer) 1</span><br><span class="line">  #添加两个分数分别是2和3的两个成员。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zadd myzset 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">  (integer) 2</span><br><span class="line">  #0表示第一个成员，-1表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES</span><br><span class="line">  1) &quot;one&quot;</span><br><span class="line">  2) &quot;1&quot;</span><br><span class="line">  3) &quot;two&quot;</span><br><span class="line">  4) &quot;2&quot;</span><br><span class="line">  5) &quot;three&quot;</span><br><span class="line">  6) &quot;3&quot;</span><br><span class="line">  #获取成员one在Sorted-Set中的位置索引值。0表示第一个位置。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zrank myzset one</span><br><span class="line">  (integer) 0</span><br><span class="line">  #成员four并不存在，因此返回nil。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zrank myzset four</span><br><span class="line">  (nil)</span><br><span class="line">  #获取myzset键中成员的数量。    </span><br><span class="line">  redis 127.0.0.1:6379&gt; zcard myzset</span><br><span class="line">  (integer) 3</span><br><span class="line">  #返回与myzset关联的Sorted-Set中，分数满足表达式1 &lt;= score &lt;= 2的成员的数量。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zcount myzset 1 2</span><br><span class="line">  (integer) 2</span><br><span class="line">  #删除成员one和two，返回实际删除成员的数量。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zrem myzset one two</span><br><span class="line">  (integer) 2</span><br><span class="line">  #查看是否删除成功。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zcard myzset</span><br><span class="line">  (integer) 1</span><br><span class="line">  #获取成员three的分数。返回值是字符串形式。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zscore myzset three</span><br><span class="line">  &quot;3&quot;</span><br><span class="line">  #由于成员two已经被删除，所以该命令返回nil。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zscore myzset two</span><br><span class="line">  (nil)</span><br><span class="line">  #将成员one的分数增加2，并返回该成员更新后的分数。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zincrby myzset 2 one</span><br><span class="line">  &quot;3&quot;</span><br><span class="line">  #将成员one的分数增加-1，并返回该成员更新后的分数。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zincrby myzset -1 one</span><br><span class="line">  &quot;2&quot;</span><br><span class="line">  #查看在更新了成员的分数后是否正确。</span><br><span class="line">  redis 127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES</span><br><span class="line">  1) &quot;one&quot;</span><br><span class="line">  2) &quot;2&quot;</span><br><span class="line">  3) &quot;two&quot;</span><br><span class="line">  4) &quot;2&quot;</span><br><span class="line">  5) &quot;three&quot;</span><br><span class="line">  6) &quot;3&quot;</span><br></pre></td></tr></table></figure><h5 id="2-ZRANGEBYSCORE-ZREMRANGEBYRANK-ZREMRANGEBYSCORE"><a href="#2-ZRANGEBYSCORE-ZREMRANGEBYRANK-ZREMRANGEBYSCORE" class="headerlink" title="2. ZRANGEBYSCORE/ZREMRANGEBYRANK/ZREMRANGEBYSCORE"></a>2. ZRANGEBYSCORE/ZREMRANGEBYRANK/ZREMRANGEBYSCORE</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del myzset</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four</span><br><span class="line">(integer) 4</span><br><span class="line">#获取分数满足表达式1 &lt;= score &lt;= 2的成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrangebyscore myzset 1 2</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">#获取分数满足表达式1 &lt; score &lt;= 2的成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrangebyscore myzset (1 2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的自己，</span><br><span class="line">#2表示从位置索引(0-based)等于2的成员开始，去后面3个成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrangebyscore myzset -inf +inf limit 2 3</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;four&quot;</span><br><span class="line">#删除分数满足表达式1 &lt;= score &lt;= 2的成员，并返回实际删除的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; zremrangebyscore myzset 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">#看出一下上面的删除是否成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrange myzset 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;four&quot;</span><br><span class="line">#删除位置索引满足表达式0 &lt;= rank &lt;= 1的成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; zremrangebyrank myzset 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">#查看上一条命令是否删除成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; zcard myzset</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h5 id="3-ZREVRANGE-ZREVRANGEBYSCORE-ZREVRANK"><a href="#3-ZREVRANGE-ZREVRANGEBYSCORE-ZREVRANK" class="headerlink" title="3.ZREVRANGE/ZREVRANGEBYSCORE/ZREVRANK:"></a>3.ZREVRANGE/ZREVRANGEBYSCORE/ZREVRANK:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; del myzset</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four</span><br><span class="line">(integer) 4</span><br><span class="line">#以位置索引从高到低的方式获取并返回此区间内的成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrevrange myzset 0 -1 WITHSCORES</span><br><span class="line">1) &quot;four&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;2&quot;</span><br><span class="line">7) &quot;one&quot;</span><br><span class="line">8) &quot;1&quot;</span><br><span class="line">#由于是从高到低的排序，所以位置等于0的是four，1是three，并以此类推。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrevrange myzset 1 3</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">#由于是从高到低的排序，所以one的位置是3。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrevrank myzset one</span><br><span class="line">(integer) 3</span><br><span class="line">#由于是从高到低的排序，所以four的位置是0。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrevrank myzset four</span><br><span class="line">(integer) 0</span><br><span class="line">#获取分数满足表达式3 &gt;= score &gt;= 0的成员，并以相反的顺序输出，即从高到底的顺序。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrevrangebyscore myzset 3 0</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">#该命令支持limit选项，其含义等同于zrangebyscore中的该选项，只是在计算位置时按照相反的顺序计算和获取。</span><br><span class="line">redis 127.0.0.1:6379&gt; zrevrangebyscore myzset 4 0 limit 1 2</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><h3 id="四、应用范围："><a href="#四、应用范围：" class="headerlink" title="四、应用范围："></a>四、应用范围：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1). 可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOPTEN的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). Sorted-Sets类型还可用于构建索引数据。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述：&quot;&gt;&lt;a href=&quot;#一、概述：&quot; class=&quot;headerlink&quot; title=&quot;一、概述：&quot;&gt;&lt;/a&gt;一、概述：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sorted-Sets和Sets
      
    
    </summary>
    
      <category term="redis笔记" scheme="http://www.rxdonny.com/categories/redis%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://www.rxdonny.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-Key操作</title>
    <link href="http://www.rxdonny.com/2018/04/12/redis--Key%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.rxdonny.com/2018/04/12/redis--Key操作/</id>
    <published>2018-04-12T08:57:24.000Z</published>
    <updated>2018-04-13T10:01:00.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在该系列的前几篇博客中，主要讲述的是与Redis数据类型相关的命令，如String、List、Set、Hashes和Sorted-Set。这些命令都具有一个共同点，即所有的操作都是针对与Key关联的Value的。而该篇博客将主要讲述与Key相关的Redis命令。学习这些命令对于学习Redis是非常重要的基础，也是能够充分挖掘Redis潜力的利器。</p><h3 id="二、相关命令（O表示时间复杂度）"><a href="#二、相关命令（O表示时间复杂度）" class="headerlink" title="二、相关命令（O表示时间复杂度）"></a>二、相关命令（O表示时间复杂度）</h3><h5 id="KEYS-pattern-O-N"><a href="#KEYS-pattern-O-N" class="headerlink" title="KEYS pattern    O(N)"></a>KEYS pattern    O(N)</h5><p>时间复杂度中的N表示数据库中Key的数量。获取所有匹配pattern参数的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。    匹配模式的键列表。</p><h5 id="DEL-key-key-…-O-N"><a href="#DEL-key-key-…-O-N" class="headerlink" title="DEL key [key …]    O(N)"></a>DEL key [key …]    O(N)</h5><p>时间复杂度中的N表示删除的Key数量。从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。    实际被删除的Key数量。</p><h5 id="EXISTS-key-O-1"><a href="#EXISTS-key-O-1" class="headerlink" title="EXISTS key     O(1)"></a>EXISTS key     O(1)</h5><p>判断指定键是否存在。    1表示存在，0表示不存在。</p><h5 id="MOVE-key-db-O-1"><a href="#MOVE-key-db-O-1" class="headerlink" title="MOVE key db     O(1)"></a>MOVE key db     O(1)</h5><p>将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。      移动成功返回1，否则0。</p><h5 id="RENAME-key-newkey-O-1"><a href="#RENAME-key-newkey-O-1" class="headerlink" title="RENAME key newkey     O(1)"></a>RENAME key newkey     O(1)</h5><p>为指定指定的键重新命名，如果参数中的两个Keys的命令相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。      </p><h5 id="RENAMENX-key-newkey-O-1"><a href="#RENAMENX-key-newkey-O-1" class="headerlink" title="RENAMENX key newkey    O(1)"></a>RENAMENX key newkey    O(1)</h5><p>如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。    1表示修改成功，否则0。</p><h5 id="PERSIST-key-O-1"><a href="#PERSIST-key-O-1" class="headerlink" title="PERSIST key    O(1)"></a>PERSIST key    O(1)</h5><p>如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。    1表示Key的过期时间被移出，0表示该Key不存在或没有过期时间。</p><h5 id="EXPIRE-key-seconds-O-1"><a href="#EXPIRE-key-seconds-O-1" class="headerlink" title="EXPIRE key seconds     O(1)"></a>EXPIRE key seconds     O(1)</h5><p>该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。     1表示超时被设置，0则表示Key不存在，或不能被设置。</p><h5 id="EXPIREAT-key-timestamp-O-1"><a href="#EXPIREAT-key-timestamp-O-1" class="headerlink" title="EXPIREAT key timestamp     O(1)"></a>EXPIREAT key timestamp     O(1)</h5><p>该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。    1表示超时被设置，0则表示Key不存在，或不能被设置。 </p><h5 id="TTL-key-O-1"><a href="#TTL-key-O-1" class="headerlink" title="TTL key     O(1)"></a>TTL key     O(1)</h5><p>获取该键所剩的超时描述。     返回所剩描述，如果该键不存在或没有超时设置，则返回-1。</p><h5 id="RANDOMKEY-O-1"><a href="#RANDOMKEY-O-1" class="headerlink" title="RANDOMKEY    O(1)"></a>RANDOMKEY    O(1)</h5><p>从当前打开的数据库中随机的返回一个Key。    返回的随机键，如果该数据库是空的则返回nil。</p><h5 id="TYPE-key-O-1"><a href="#TYPE-key-O-1" class="headerlink" title="TYPE key     O(1)"></a>TYPE key     O(1)</h5><p>获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。    返回的字符串为string、list、set、hash和zset，如果key不存在返回none。</p><h5 id="SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination-O-N-M-log-M"><a href="#SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination-O-N-M-log-M" class="headerlink" title="SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC|DESC] [ALPHA] [STORE destination]     O(N+M*log(M))"></a>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC|DESC] [ALPHA] [STORE destination]     O(N+M*log(M))</h5><p>这个命令相对来说是比较复杂的，因此我们这里只是给出最基本的用法，有兴趣的网友可以去参考redis的官方文档。    返回排序后的原始列表。</p><h3 id="三、命令示例："><a href="#三、命令示例：" class="headerlink" title="三、命令示例："></a>三、命令示例：</h3><h5 id="1-KEYS-RENAME-DEL-EXISTS-MOVE-RENAMENX"><a href="#1-KEYS-RENAME-DEL-EXISTS-MOVE-RENAMENX" class="headerlink" title="1. KEYS/RENAME/DEL/EXISTS/MOVE/RENAMENX:"></a>1. KEYS/RENAME/DEL/EXISTS/MOVE/RENAMENX:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行下启动Redis客户端工具。</span><br><span class="line">   /&gt; redis-cli</span><br><span class="line">   #清空当前选择的数据库，以便于对后面示例的理解。</span><br><span class="line">   redis 127.0.0.1:6379&gt; flushdb</span><br><span class="line">   OK</span><br><span class="line">   #添加String类型的模拟数据。</span><br><span class="line">   redis 127.0.0.1:6379&gt; set mykey 2</span><br><span class="line">   OK</span><br><span class="line">   redis 127.0.0.1:6379&gt; set mykey2 &quot;hello&quot;</span><br><span class="line">   OK</span><br><span class="line">   #添加Set类型的模拟数据。</span><br><span class="line">   redis 127.0.0.1:6379&gt; sadd mysetkey 1 2 3</span><br><span class="line">   (integer) 3</span><br><span class="line">   #添加Hash类型的模拟数据。</span><br><span class="line">   redis 127.0.0.1:6379&gt; hset mmtest username &quot;stephen&quot;</span><br><span class="line">   (integer) 1</span><br><span class="line">   #根据参数中的模式，获取当前数据库中符合该模式的所有key，从输出可以看出，该命令在执行时并不区分与Key关联的Value类型。</span><br><span class="line">   redis 127.0.0.1:6379&gt; keys my*</span><br><span class="line">   1) &quot;mysetkey&quot;</span><br><span class="line">   2) &quot;mykey&quot;</span><br><span class="line">   3) &quot;mykey2&quot;</span><br><span class="line">   #删除了两个Keys。</span><br><span class="line">   redis 127.0.0.1:6379&gt; del mykey mykey2</span><br><span class="line">   (integer) 2</span><br><span class="line">   #查看一下刚刚删除的Key是否还存在，从返回结果看，mykey确实已经删除了。</span><br><span class="line">   redis 127.0.0.1:6379&gt; exists mykey</span><br><span class="line">   (integer) 0</span><br><span class="line">   #查看一下没有删除的Key，以和上面的命令结果进行比较。</span><br><span class="line">   redis 127.0.0.1:6379&gt; exists mysetkey</span><br><span class="line">   (integer) 1</span><br><span class="line">   #将当前数据库中的mysetkey键移入到ID为1的数据库中，从结果可以看出已经移动成功。</span><br><span class="line">   redis 127.0.0.1:6379&gt; move mysetkey 1</span><br><span class="line">   (integer) 1</span><br><span class="line">   #打开ID为1的数据库。</span><br><span class="line">   redis 127.0.0.1:6379&gt; select 1</span><br><span class="line">   OK</span><br><span class="line">   #查看一下刚刚移动过来的Key是否存在，从返回结果看已经存在了。</span><br><span class="line">   redis 127.0.0.1:6379[1]&gt; exists mysetkey</span><br><span class="line">   (integer) 1</span><br><span class="line">   #在重新打开ID为0的缺省数据库。</span><br><span class="line">   redis 127.0.0.1:6379[1]&gt; select 0</span><br><span class="line">   OK</span><br><span class="line">   #查看一下刚刚移走的Key是否已经不存在，从返回结果看已经移走。</span><br><span class="line">   redis 127.0.0.1:6379&gt; exists mysetkey</span><br><span class="line">   (integer) 0</span><br><span class="line">   #准备新的测试数据。    </span><br><span class="line">   redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;</span><br><span class="line">   OK</span><br><span class="line">   #将mykey改名为mykey1</span><br><span class="line">   redis 127.0.0.1:6379&gt; rename mykey mykey1</span><br><span class="line">   OK</span><br><span class="line">   #由于mykey已经被重新命名，再次获取将返回nil。</span><br><span class="line">   redis 127.0.0.1:6379&gt; get mykey</span><br><span class="line">   (nil)</span><br><span class="line">   #通过新的键名获取。</span><br><span class="line">   redis 127.0.0.1:6379&gt; get mykey1</span><br><span class="line">   &quot;hello&quot;</span><br><span class="line">   #由于mykey已经不存在了，所以返回错误信息。</span><br><span class="line">   redis 127.0.0.1:6379&gt; rename mykey mykey1</span><br><span class="line">   (error) ERR no such key</span><br><span class="line">   #为renamenx准备测试key</span><br><span class="line">   redis 127.0.0.1:6379&gt; set oldkey &quot;hello&quot;</span><br><span class="line">   OK</span><br><span class="line">   redis 127.0.0.1:6379&gt; set newkey &quot;world&quot;</span><br><span class="line">   OK</span><br><span class="line">   #由于newkey已经存在，因此该命令未能成功执行。</span><br><span class="line">   redis 127.0.0.1:6379&gt; renamenx oldkey newkey</span><br><span class="line">   (integer) 0</span><br><span class="line">   #查看newkey的值，发现它也没有被renamenx覆盖。</span><br><span class="line">   redis 127.0.0.1:6379&gt; get newkey</span><br><span class="line">   &quot;world&quot;</span><br></pre></td></tr></table></figure><h5 id="2-PERSIST-EXPIRE-EXPIREAT-TTL"><a href="#2-PERSIST-EXPIRE-EXPIREAT-TTL" class="headerlink" title="2. PERSIST/EXPIRE/EXPIREAT/TTL:"></a>2. PERSIST/EXPIRE/EXPIREAT/TTL:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#为后面的示例准备的测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">#将该键的超时设置为100秒。</span><br><span class="line">redis 127.0.0.1:6379&gt; expire mykey 100</span><br><span class="line">(integer) 1</span><br><span class="line">#通过ttl命令查看一下还剩下多少秒。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) 97</span><br><span class="line">#立刻执行persist命令，该存在超时的键变成持久化的键，即将该Key的超时去掉。</span><br><span class="line">redis 127.0.0.1:6379&gt; persist mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#ttl的返回值告诉我们，该键已经没有超时了。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) -1</span><br><span class="line">#为后面的expire命令准备数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">#设置该键的超时被100秒。</span><br><span class="line">redis 127.0.0.1:6379&gt; expire mykey 100</span><br><span class="line">(integer) 1</span><br><span class="line">#用ttl命令看一下当前还剩下多少秒，从结果中可以看出还剩下96秒。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) 96</span><br><span class="line">#重新更新该键的超时时间为20秒，从返回值可以看出该命令执行成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; expire mykey 20</span><br><span class="line">(integer) 1</span><br><span class="line">#再用ttl确认一下，从结果中可以看出果然被更新了。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) 17</span><br><span class="line">#立刻更新该键的值，以使其超时无效。</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;world&quot;</span><br><span class="line">OK</span><br><span class="line">#从ttl的结果可以看出，在上一条修改该键的命令执行后，该键的超时也无效了。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h5 id="3-TYPE-RANDOMKEY-SORT"><a href="#3-TYPE-RANDOMKEY-SORT" class="headerlink" title="3.TYPE/RANDOMKEY/SORT:"></a>3.TYPE/RANDOMKEY/SORT:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#由于mm键在数据库中不存在，因此该命令返回none。</span><br><span class="line"> redis 127.0.0.1:6379&gt; type mm</span><br><span class="line"> none</span><br><span class="line"> #mykey的值是字符串类型，因此返回string。</span><br><span class="line"> redis 127.0.0.1:6379&gt; type mykey</span><br><span class="line"> string</span><br><span class="line"> #准备一个值是set类型的键。</span><br><span class="line"> redis 127.0.0.1:6379&gt; sadd mysetkey 1 2</span><br><span class="line"> (integer) 2</span><br><span class="line"> #mysetkey的键是set，因此返回字符串set。</span><br><span class="line"> redis 127.0.0.1:6379&gt; type mysetkey</span><br><span class="line"> set</span><br><span class="line"> #返回数据库中的任意键。</span><br><span class="line"> redis 127.0.0.1:6379&gt; randomkey</span><br><span class="line"> &quot;oldkey&quot;</span><br><span class="line"> #清空当前打开的数据库。</span><br><span class="line"> redis 127.0.0.1:6379&gt; flushdb</span><br><span class="line"> OK</span><br><span class="line"> #由于没有数据了，因此返回nil。</span><br><span class="line"> redis 127.0.0.1:6379&gt; randomkey</span><br><span class="line"> (nil)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述：&quot;&gt;&lt;a href=&quot;#一、概述：&quot; class=&quot;headerlink&quot; title=&quot;一、概述：&quot;&gt;&lt;/a&gt;一、概述：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在该系列的前几篇博客中，主要讲述
      
    
    </summary>
    
      <category term="redis笔记" scheme="http://www.rxdonny.com/categories/redis%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://www.rxdonny.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据类型-Set</title>
    <link href="http://www.rxdonny.com/2018/04/12/redis--Set%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.rxdonny.com/2018/04/12/redis--Set类型/</id>
    <published>2018-04-12T06:29:24.000Z</published>
    <updated>2018-04-13T09:26:50.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销</p><h3 id="二、相关命令（O表示时间复杂度）"><a href="#二、相关命令（O表示时间复杂度）" class="headerlink" title="二、相关命令（O表示时间复杂度）"></a>二、相关命令（O表示时间复杂度）</h3><h5 id="1、SADD-key-member-member-…-O-N-时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。-本次操作实际插入的成员数量。"><a href="#1、SADD-key-member-member-…-O-N-时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。-本次操作实际插入的成员数量。" class="headerlink" title="1、SADD key member [member …]    O(N)    时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。    本次操作实际插入的成员数量。"></a>1、SADD key member [member …]    O(N)    时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。    本次操作实际插入的成员数量。</h5><h5 id="2、SCARD-key-O-1"><a href="#2、SCARD-key-O-1" class="headerlink" title="2、SCARD key    O(1)"></a>2、SCARD key    O(1)</h5><p>获取Set中成员的数量。    返回Set中成员的数量，如果该Key并不存在，返回0。</p><h5 id="3、SISMEMBER-key-member-O-1"><a href="#3、SISMEMBER-key-member-O-1" class="headerlink" title="3、SISMEMBER key member    O(1)"></a>3、SISMEMBER key member    O(1)</h5><p>判断参数中指定成员是否已经存在于与Key相关联的Set集合中。    1表示已经存在，0表示不存在，或该Key本身并不存在。</p><h5 id="4、SMEMBERS-key-O-N"><a href="#4、SMEMBERS-key-O-N" class="headerlink" title="4、SMEMBERS key    O(N)"></a>4、SMEMBERS key    O(N)</h5><p>时间复杂度中的N表示Set中已经存在的成员数量。获取与该Key关联的Set中所有的成员。<br>返回Set中所有的成员。</p><h5 id="5、SPOP-key-O-1"><a href="#5、SPOP-key-O-1" class="headerlink" title="5、SPOP key     O(1)"></a>5、SPOP key     O(1)</h5><p>随机的移除并返回Set中的某一成员。由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。    返回移除的成员，如果该Key并不存在，则返回nil。</p><h5 id="6、SREM-key-member-member-…-O-N"><a href="#6、SREM-key-member-member-…-O-N" class="headerlink" title="6、SREM key member [member …]    O(N)"></a>6、SREM key member [member …]    O(N)</h5><p>时间复杂度中的N表示被删除的成员数量。从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。从Set中实际移除的成员数量，如果没有则返回0。</p><h5 id="7、SRANDMEMBER-key-O-1"><a href="#7、SRANDMEMBER-key-O-1" class="headerlink" title="7、SRANDMEMBER key     O(1)"></a>7、SRANDMEMBER key     O(1)</h5><p>和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。    返回随机位置的成员，如果Key不存在则返回nil。</p><h5 id="8、SMOVE-source-destination-member-O-1"><a href="#8、SMOVE-source-destination-member-O-1" class="headerlink" title="8、SMOVE source destination member    O(1)"></a>8、SMOVE source destination member    O(1)</h5><p>原子性的将参数中的成员从source键移入到destination键所关联的Set中。因此在某一时刻，该成员或者出现在source中，或者出现在destination中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。如果和Key关联的Value不是Set，将返回相关的错误信息。    1表示正常移动，0表示source中并不包含参数成员。</p><h5 id="9、SDIFF-key-key-…-O-N"><a href="#9、SDIFF-key-key-…-O-N" class="headerlink" title="9、SDIFF key [key …]    O(N)"></a>9、SDIFF key [key …]    O(N)</h5><p>时间复杂度中的N表示所有Sets中成员的总数量。返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。    差异结果成员的集合。</p><h5 id="10、SDIFFSTORE-destination-key-key-…-O-N"><a href="#10、SDIFFSTORE-destination-key-key-…-O-N" class="headerlink" title="10、SDIFFSTORE destination key [key …]     O(N)"></a>10、SDIFFSTORE destination key [key …]     O(N)</h5><p>该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    返回差异成员的数量。</p><h5 id="11、SINTER-key-key-…-O-N-M"><a href="#11、SINTER-key-key-…-O-N-M" class="headerlink" title="11、SINTER key [key …]     O(N*M)"></a>11、SINTER key [key …]     O(N*M)</h5><p>时间复杂度中的N表示最小Set中元素的数量，M则表示参数中Sets的数量。该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。    交集结果成员的集合。</p><h5 id="12、SINTERSTORE-destination-key-key-…-O-N-M"><a href="#12、SINTERSTORE-destination-key-key-…-O-N-M" class="headerlink" title="12、SINTERSTORE destination key [key …]    O(N*M)"></a>12、SINTERSTORE destination key [key …]    O(N*M)</h5><p>该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    返回交集成员的数量。 </p><h5 id="13、SUNION-key-key-…-O-N"><a href="#13、SUNION-key-key-…-O-N" class="headerlink" title="13、SUNION key [key …]     O(N)"></a>13、SUNION key [key …]     O(N)</h5><p>时间复杂度中的N表示所有Sets中成员的总数量。该命令将返回参数中所有Keys关联的Sets中成员的并集。并集结果成员的集合。</p><h5 id="14、SUNIONSTORE-destination-key-key-…-O-N"><a href="#14、SUNIONSTORE-destination-key-key-…-O-N" class="headerlink" title="14、SUNIONSTORE destination key [key …]     O(N)"></a>14、SUNIONSTORE destination key [key …]     O(N)</h5><p>该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。     返回并集成员的数量。</p><h3 id="三、命令示例："><a href="#三、命令示例：" class="headerlink" title="三、命令示例："></a>三、命令示例：</h3><h5 id="1-SADD-SMEMBERS-SCARD-SISMEMBER"><a href="#1-SADD-SMEMBERS-SCARD-SISMEMBER" class="headerlink" title="1. SADD/SMEMBERS/SCARD/SISMEMBER:"></a>1. SADD/SMEMBERS/SCARD/SISMEMBER:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行下启动Redis的客户端程序。</span><br><span class="line">   /&gt; redis-cli</span><br><span class="line">   #插入测试数据，由于该键myset之前并不存在，因此参数中的三个成员都被正常插入。</span><br><span class="line">   redis 127.0.0.1:6379&gt; sadd myset a b c</span><br><span class="line">   (integer) 3</span><br><span class="line">   #由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员。</span><br><span class="line">   redis 127.0.0.1:6379&gt; sadd myset a d e</span><br><span class="line">   (integer) 2</span><br><span class="line">   #判断a是否已经存在，返回值为1表示存在。</span><br><span class="line">   redis 127.0.0.1:6379&gt; sismember myset a</span><br><span class="line">   (integer) 1</span><br><span class="line">   #判断f是否已经存在，返回值为0表示不存在。</span><br><span class="line">   redis 127.0.0.1:6379&gt; sismember myset f</span><br><span class="line">   (integer) 0</span><br><span class="line">   #通过smembers命令查看插入的结果，从结果可以，输出的顺序和插入顺序无关。</span><br><span class="line">   redis 127.0.0.1:6379&gt; smembers myset</span><br><span class="line">   1) &quot;c&quot;</span><br><span class="line">   2) &quot;d&quot;</span><br><span class="line">   3) &quot;a&quot;</span><br><span class="line">   4) &quot;b&quot;</span><br><span class="line">   5) &quot;e&quot;</span><br><span class="line">   #获取Set集合中元素的数量。</span><br><span class="line">   redis 127.0.0.1:6379&gt; scard myset</span><br><span class="line">   (integer) 5</span><br></pre></td></tr></table></figure><h5 id="2-SPOP-SREM-SRANDMEMBER-SMOVE"><a href="#2-SPOP-SREM-SRANDMEMBER-SMOVE" class="headerlink" title="2. SPOP/SREM/SRANDMEMBER/SMOVE:"></a>2. SPOP/SREM/SRANDMEMBER/SMOVE:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面的测试。</span><br><span class="line">redis 127.0.0.1:6379&gt; del myset</span><br><span class="line">(integer) 1</span><br><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd myset a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">#查看Set中成员的位置。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">#从结果可以看出，该命令确实是随机的返回了某一成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; srandmember myset</span><br><span class="line">&quot;c&quot;</span><br><span class="line">#Set中尾部的成员b被移出并返回，事实上b并不是之前插入的第一个或最后一个成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;b&quot;</span><br><span class="line">#查看移出后Set的成员信息。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为2。</span><br><span class="line">redis 127.0.0.1:6379&gt; srem myset a d f</span><br><span class="line">(integer) 2</span><br><span class="line">#查看移出后的输出结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">#为后面的smove命令准备数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd myset a b</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd myset2 c d</span><br><span class="line">(integer) 2</span><br><span class="line">#将a从myset移到myset2，从结果可以看出移动成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; smove myset myset2 a</span><br><span class="line">(integer) 1</span><br><span class="line">#再次将a从myset移到myset2，由于此时a已经不是myset的成员了，因此移动失败并返回0。</span><br><span class="line">redis 127.0.0.1:6379&gt; smove myset myset2 a</span><br><span class="line">(integer) 0</span><br><span class="line">#分别查看myset和myset2的成员，确认移动是否真的成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure><h5 id="3-SDIFF-SDIFFSTORE-SINTER-SINTERSTORE"><a href="#3-SDIFF-SDIFFSTORE-SINTER-SINTERSTORE" class="headerlink" title="3.SDIFF/SDIFFSTORE/SINTER/SINTERSTORE:"></a>3.SDIFF/SDIFFSTORE/SINTER/SINTERSTORE:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#为后面的命令准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd myset a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd myset2 c</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd myset3 a c e</span><br><span class="line">(integer) 3</span><br><span class="line">#myset和myset2相比，a、b和d三个成员是两者之间的差异成员。再用这个结果继续和myset3进行差异比较，b和d是myset3不存在的成员。</span><br><span class="line">redis 127.0.0.1:6379&gt; sdiff myset myset2 myset3</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">#将3个集合的差异成员存在在diffkey关联的Set中，并返回插入的成员数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; sdiffstore diffkey myset myset2 myset3</span><br><span class="line">(integer) 2</span><br><span class="line">#查看一下sdiffstore的操作结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers diffkey</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">#从之前准备的数据就可以看出，这三个Set的成员交集只有c。</span><br><span class="line">redis 127.0.0.1:6379&gt; sinter myset myset2 myset3</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">#将3个集合中的交集成员存储到与interkey关联的Set中，并返回交集成员的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; sinterstore interkey myset myset2 myset3</span><br><span class="line">(integer) 1</span><br><span class="line">#查看一下sinterstore的操作结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers interkey</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">#获取3个集合中的成员的并集。    </span><br><span class="line">redis 127.0.0.1:6379&gt; sunion myset myset2 myset3</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;e&quot;</span><br><span class="line">5) &quot;a&quot;</span><br><span class="line">#将3个集合中成员的并集存储到unionkey关联的set中，并返回并集成员的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; sunionstore unionkey myset myset2 myset3</span><br><span class="line">(integer) 5</span><br><span class="line">#查看一下suiionstore的操作结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers unionkey</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;e&quot;</span><br><span class="line">5) &quot;a&quot;</span><br></pre></td></tr></table></figure><h3 id="四、应用范围："><a href="#四、应用范围：" class="headerlink" title="四、应用范围："></a>四、应用范围：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1).可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述：&quot;&gt;&lt;a href=&quot;#一、概述：&quot; class=&quot;headerlink&quot; title=&quot;一、概述：&quot;&gt;&lt;/a&gt;一、概述：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Redis中，我们可以将Set
      
    
    </summary>
    
      <category term="redis笔记" scheme="http://www.rxdonny.com/categories/redis%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://www.rxdonny.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据类型-List</title>
    <link href="http://www.rxdonny.com/2018/04/12/redis--List%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.rxdonny.com/2018/04/12/redis--List类型/</id>
    <published>2018-04-12T05:19:24.000Z</published>
    <updated>2018-04-13T09:18:42.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。</p><h3 id="二、相关命令（O表示时间复杂度）"><a href="#二、相关命令（O表示时间复杂度）" class="headerlink" title="二、相关命令（O表示时间复杂度）"></a>二、相关命令（O表示时间复杂度）</h3><h5 id="1、LPUSH-key-value-value-…-O-1"><a href="#1、LPUSH-key-value-value-…-O-1" class="headerlink" title="1、LPUSH key value [value …]     O(1)"></a>1、LPUSH key value [value …]     O(1)</h5><p>在指定Key所关联的List  Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。     插入后链表中元素的数量。</p><h5 id="2、LPUSHX-key-value-O-1"><a href="#2、LPUSHX-key-value-O-1" class="headerlink" title="2、LPUSHX key value     O(1)"></a>2、LPUSHX key value     O(1)</h5><p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。    插入后链表中元素的数量。 </p><h5 id="3、LRANGE-key-start-stop-O-S-N"><a href="#3、LRANGE-key-start-stop-O-S-N" class="headerlink" title="3、LRANGE key start stop     O(S+N)"></a>3、LRANGE key start stop     O(S+N)</h5><p>时间复杂度中的S为start参数表示的偏移量，N表示元素的数量。该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。    返回指定范围内元素的列表。</p><h5 id="4、LPOP-key-O-1"><a href="#4、LPOP-key-O-1" class="headerlink" title="4、LPOP key     O(1)"></a>4、LPOP key     O(1)</h5><p>返回并弹出指定Key关联的链表中的第一个元素，即头部元素，。如果该Key不存，返回nil。    链表头部的元素。</p><h5 id="5、LLEN-key-O-1"><a href="#5、LLEN-key-O-1" class="headerlink" title="5、LLEN key    O(1)"></a>5、LLEN key    O(1)</h5><p>返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。    链表中元素的数量。</p><h5 id="6、LREM-key-count-value-O-N"><a href="#6、LREM-key-count-value-O-N" class="headerlink" title="6、LREM key count value     O(N)"></a>6、LREM key count value     O(N)</h5><p>时间复杂度中N表示链表中元素的数量。在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。    返回被删除的元素数量。</p><h5 id="7、LSET-key-index-value-O-N"><a href="#7、LSET-key-index-value-O-N" class="headerlink" title="7、LSET key index value     O(N)"></a>7、LSET key index value     O(N)</h5><p>时间复杂度中N表示链表中元素的数量。但是设定头部或尾部的元素时，其时间复杂度为O(1)。设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。     </p><h5 id="8、LINDEX-key-index-O-N"><a href="#8、LINDEX-key-index-O-N" class="headerlink" title="8、LINDEX key index     O(N)"></a>8、LINDEX key index     O(N)</h5><p>时间复杂度中N表示在找到该元素时需要遍历的元素数量。对于头部或尾部元素，其时间复杂度为O(1)。该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。    返回请求的元素，如果index超出范围，则返回nil。</p><h5 id="9、LTRIM-key-start-stop-O-N"><a href="#9、LTRIM-key-start-stop-O-N" class="headerlink" title="9、LTRIM key start stop     O(N)"></a>9、LTRIM key start stop     O(N)</h5><p>N表示被删除的元素数量。该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不错报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。     </p><h5 id="10、LINSERT-key-BEFORE-AFTER-pivot-value-O-N"><a href="#10、LINSERT-key-BEFORE-AFTER-pivot-value-O-N" class="headerlink" title="10、LINSERT key BEFORE|AFTER pivot value     O(N)"></a>10、LINSERT key BEFORE|AFTER pivot value     O(N)</h5><p>时间复杂度中N表示在找到该元素pivot之前需要遍历的元素数量。这样意味着如果pivot位于链表的头部或尾部时，该命令的时间复杂度为O(1)。该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。    成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</p><h5 id="11、RPUSH-key-value-value-…-O-1"><a href="#11、RPUSH-key-value-value-…-O-1" class="headerlink" title="11、RPUSH key value [value …]     O(1)"></a>11、RPUSH key value [value …]     O(1)</h5><p>在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。     插入后链表中元素的数量。 </p><h5 id="12、RPUSHX-key-value-O-1"><a href="#12、RPUSHX-key-value-O-1" class="headerlink" title="12、RPUSHX key value     O(1)"></a>12、RPUSHX key value     O(1)</h5><p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。     插入后链表中元素的数量。 </p><h5 id="13、RPOP-key-O-1"><a href="#13、RPOP-key-O-1" class="headerlink" title="13、RPOP key     O(1)"></a>13、RPOP key     O(1)</h5><p>返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。     链表尾部的元素。 </p><h5 id="14、RPOPLPUSH-source-destination-O-1"><a href="#14、RPOPLPUSH-source-destination-O-1" class="headerlink" title="14、RPOPLPUSH source destination     O(1)"></a>14、RPOPLPUSH source destination     O(1)</h5><p>原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。    返回弹出和插入的元素。</p><h3 id="三、命令示例："><a href="#三、命令示例：" class="headerlink" title="三、命令示例："></a>三、命令示例：</h3><h5 id="1-LPUSH-LPUSHX-LRANGE"><a href="#1-LPUSH-LPUSHX-LRANGE" class="headerlink" title="1. LPUSH/LPUSHX/LRANGE:"></a>1. LPUSH/LPUSHX/LRANGE:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/&gt; redis-cli    #在Shell提示符下启动redis客户端工具。</span><br><span class="line"> redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line"> (integer) 1</span><br><span class="line"> #mykey键并不存在，该命令会创建该键及与其关联的List，之后在将参数中的values从左到右依次插入。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lpush mykey a b c d</span><br><span class="line"> (integer) 4</span><br><span class="line"> #取从位置0开始到位置2结束的3个元素。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lrange mykey 0 2</span><br><span class="line"> 1) &quot;d&quot;</span><br><span class="line"> 2) &quot;c&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> #取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line"> 1) &quot;d&quot;</span><br><span class="line"> 2) &quot;c&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> 4) &quot;a&quot;</span><br><span class="line"> #mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lpushx mykey2 e</span><br><span class="line"> (integer) 0</span><br><span class="line"> #可以看到mykey2没有关联任何List Value。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</span><br><span class="line"> (empty list or set)</span><br><span class="line"> #mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lpushx mykey e</span><br><span class="line"> (integer) 5</span><br><span class="line"> #获取该键的List Value的头部元素。</span><br><span class="line"> redis 127.0.0.1:6379&gt; lrange mykey 0 0</span><br><span class="line"> 1) &quot;e&quot;</span><br></pre></td></tr></table></figure><h5 id="2-LPOP-LLEN"><a href="#2-LPOP-LLEN" class="headerlink" title="2. LPOP/LLEN:"></a>2. LPOP/LLEN:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> redis 127.0.0.1:6379&gt; lpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop mykey</span><br><span class="line">&quot;d&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop mykey</span><br><span class="line">&quot;c&quot;</span><br><span class="line">#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2</span><br><span class="line">redis 127.0.0.1:6379&gt; llen mykey</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h5 id="3-LREM-LSET-LINDEX-LTRIM"><a href="#3-LREM-LSET-LINDEX-LTRIM" class="headerlink" title="3. LREM/LSET/LINDEX/LTRIM:"></a>3. LREM/LSET/LINDEX/LTRIM:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    #为后面的示例准备测试数据。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lpush mykey a b c d a c</span><br><span class="line">    (integer) 6</span><br><span class="line">    #从头部(left)向尾部(right)变量链表，删除2个值等于a的元素，返回值为实际删除的数量。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lrem mykey 2 a</span><br><span class="line">    (integer) 2</span><br><span class="line">    #看出删除后链表中的全部元素。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">    1) &quot;c&quot;</span><br><span class="line">    2) &quot;d&quot;</span><br><span class="line">    3) &quot;c&quot;</span><br><span class="line">    4) &quot;b&quot;</span><br><span class="line">    #获取索引值为1(头部的第二个元素)的元素值。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">    &quot;d&quot;</span><br><span class="line">    #将索引值为1(头部的第二个元素)的元素值设置为新值e。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lset mykey 1 e</span><br><span class="line">    OK</span><br><span class="line">    #查看是否设置成功。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">    &quot;e&quot;</span><br><span class="line">    #索引值6超过了链表中元素的数量，该命令返回nil。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lindex mykey 6</span><br><span class="line">    (nil)</span><br><span class="line">    #设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lset mykey 6 hh</span><br><span class="line">    (error) ERR index out of range</span><br><span class="line">    #仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。</span><br><span class="line">    redis 127.0.0.1:6379&gt; ltrim mykey 0 2</span><br><span class="line">    OK</span><br><span class="line">    #查看trim后的结果。</span><br><span class="line">    redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">    1) &quot;c&quot;</span><br><span class="line">    2) &quot;e&quot;</span><br><span class="line">    3) &quot;c&quot;</span><br><span class="line">```    </span><br><span class="line"> </span><br><span class="line">##### 4. LINSERT:</span><br></pre></td></tr></table></figure><pre><code> #删除该键便于后面的测试。redis 127.0.0.1:6379&gt; del mykey(integer) 1#为后面的示例准备测试数据。redis 127.0.0.1:6379&gt; lpush mykey a b c d e(integer) 5#在a的前面插入新元素a1。redis 127.0.0.1:6379&gt; linsert mykey before a a1(integer) 6#查看是否插入成功，从结果看已经插入。注意lindex的index值是0-based。redis 127.0.0.1:6379&gt; lindex mykey 0&quot;e&quot;#在e的后面插入新元素e2，从返回结果看已经插入成功。redis 127.0.0.1:6379&gt; linsert mykey after e e2(integer) 7#再次查看是否插入成功。redis 127.0.0.1:6379&gt; lindex mykey 1&quot;e2&quot;#在不存在的元素之前或之后插入新元素，该命令操作失败，并返回-1。redis 127.0.0.1:6379&gt; linsert mykey after k a(integer) -1#为不存在的Key插入新元素，该命令操作失败，返回0。redis 127.0.0.1:6379&gt; linsert mykey1 after a a2(integer) 0</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### 5. RPUSH/RPUSHX/RPOP/RPOPLPUSH:</span><br></pre></td></tr></table></figure><pre><code>#删除该键，以便于后面的测试。redis 127.0.0.1:6379&gt; del mykey(integer) 1#从链表的尾部插入参数中给出的values，插入顺序是从左到右依次插入。redis 127.0.0.1:6379&gt; rpush mykey a b c d(integer) 4#通过lrange的可以获悉rpush在插入多值时的插入顺序。redis 127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;d&quot;#该键已经存在并且包含4个元素，rpushx命令将执行成功，并将元素e插入到链表的尾部。redis 127.0.0.1:6379&gt; rpushx mykey e(integer) 5#通过lindex命令可以看出之前的rpushx命令确实执行成功，因为索引值为4的元素已经是新元素了。redis 127.0.0.1:6379&gt; lindex mykey 4&quot;e&quot;#由于mykey2键并不存在，因此该命令不会插入数据，其返回值为0。redis 127.0.0.1:6379&gt; rpushx mykey2 e(integer) 0#在执行rpoplpush命令前，先看一下mykey中链表的元素有哪些，注意他们的位置关系。redis 127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;d&quot;5) &quot;e&quot;#将mykey的尾部元素e弹出，同时再插入到mykey2的头部(原子性的完成这两步操作)。redis 127.0.0.1:6379&gt; rpoplpush mykey mykey2&quot;e&quot;#通过lrange命令查看mykey在弹出尾部元素后的结果。redis 127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;d&quot;#通过lrange命令查看mykey2在插入元素后的结果。redis 127.0.0.1:6379&gt; lrange mykey2 0 -11) &quot;e&quot;#将source和destination设为同一键，将mykey中的尾部元素移到其头部。redis 127.0.0.1:6379&gt; rpoplpush mykey mykey&quot;d&quot;#查看移动结果。redis 127.0.0.1:6379&gt; lrange mykey 0 -11) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;</code></pre><p>```</p><h3 id="四、链表结构的小技巧："><a href="#四、链表结构的小技巧：" class="headerlink" title="四、链表结构的小技巧："></a>四、链表结构的小技巧：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对链表结构的Value，Redis在其官方文档中给出了一些实用技巧，如RPOPLPUSH命令，下面给出具体的解释。<br>Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述：&quot;&gt;&lt;a href=&quot;#一、概述：&quot; class=&quot;headerlink&quot; title=&quot;一、概述：&quot;&gt;&lt;/a&gt;一、概述：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Redis中，List类型是按
      
    
    </summary>
    
      <category term="redis笔记" scheme="http://www.rxdonny.com/categories/redis%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://www.rxdonny.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据类型-String</title>
    <link href="http://www.rxdonny.com/2018/04/12/redis--String%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.rxdonny.com/2018/04/12/redis--String类型/</id>
    <published>2018-04-12T03:11:24.000Z</published>
    <updated>2018-04-13T08:35:28.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</p><h3 id="二、相关命令（O表示时间复杂度）"><a href="#二、相关命令（O表示时间复杂度）" class="headerlink" title="二、相关命令（O表示时间复杂度）"></a>二、相关命令（O表示时间复杂度）</h3><h5 id="1、APPEND-key-value-O-1"><a href="#1、APPEND-key-value-O-1" class="headerlink" title="1、APPEND key value  O(1)"></a>1、APPEND key value  O(1)</h5><p>如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。    追加后Value的长度。</p><h5 id="2、DECR-key-O-1"><a href="#2、DECR-key-O-1" class="headerlink" title="2、DECR key    O(1)"></a>2、DECR key    O(1)</h5><p>将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。    递减后的Value值。</p><h5 id="3、INCR-key-O-1"><a href="#3、INCR-key-O-1" class="headerlink" title="3、INCR key    O(1)"></a>3、INCR key    O(1)</h5><p>将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。     递增后的Value值。 </p><h5 id="4、DECRBY-key-decrement-O-1"><a href="#4、DECRBY-key-decrement-O-1" class="headerlink" title="4、DECRBY key decrement      O(1)"></a>4、DECRBY key decrement      O(1)</h5><p>将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。     减少后的Value值。</p><h5 id="5、INCRBY-key-increment-O-1"><a href="#5、INCRBY-key-increment-O-1" class="headerlink" title="5、INCRBY key increment      O(1)"></a>5、INCRBY key increment      O(1)</h5><p>将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。     增加后的Value值。</p><h5 id="6、GET-key-O-1"><a href="#6、GET-key-O-1" class="headerlink" title="6、GET key     O(1)"></a>6、GET key     O(1)</h5><p>获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。     与该Key相关的Value，如果该Key不存在，返回nil。</p><h5 id="SET-key-value-O-1"><a href="#SET-key-value-O-1" class="headerlink" title="SET key value     O(1)"></a>SET key value     O(1)</h5><p>设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。    总是返回”OK”。</p><h5 id="7、GETSET-key-value-O-1"><a href="#7、GETSET-key-value-O-1" class="headerlink" title="7、GETSET key value    O(1)"></a>7、GETSET key value    O(1)</h5><p>原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。    返回该Key的原有值，如果该Key之前并不存在，则返回nil。</p><h5 id="STRLEN-key-O-1"><a href="#STRLEN-key-O-1" class="headerlink" title="STRLEN key    O(1)"></a>STRLEN key    O(1)</h5><p>返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。    返回指定Key的Value字符长度，如果该Key不存在，返回0。</p><h5 id="8、SETEX-key-seconds-value-O-1"><a href="#8、SETEX-key-seconds-value-O-1" class="headerlink" title="8、SETEX key seconds value    O(1)"></a>8、SETEX key seconds value    O(1)</h5><p>原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。     </p><h5 id="9、SETNX-key-value-O-1"><a href="#9、SETNX-key-value-O-1" class="headerlink" title="9、SETNX key value     O(1)"></a>9、SETNX key value     O(1)</h5><p>如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。    1表示设置成功，否则0。</p><h5 id="10、SETRANGE-key-offset-value-O-1"><a href="#10、SETRANGE-key-offset-value-O-1" class="headerlink" title="10、SETRANGE key offset value     O(1)"></a>10、SETRANGE key offset value     O(1)</h5><p>替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset -strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。     修改后的字符串Value长度。</p><h5 id="11、GETRANGE-key-start-end-O-1"><a href="#11、GETRANGE-key-start-end-O-1" class="headerlink" title="11、GETRANGE key start end    O(1)"></a>11、GETRANGE key start end    O(1)</h5><p>如果截取的字符串长度很短，我们可以该命令的时间复杂度视为O(1)，否则就是O(N)，这里N表示截取的子字符串长度。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。    子字符串 </p><h5 id="12、SETBIT-key-offset-value-O-1"><a href="#12、SETBIT-key-offset-value-O-1" class="headerlink" title="12、SETBIT key offset value     O(1)"></a>12、SETBIT key offset value     O(1)</h5><p>设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。     在指定Offset上的BIT原有值。</p><h5 id="13、GETBIT-key-offset-O-1"><a href="#13、GETBIT-key-offset-O-1" class="headerlink" title="13、GETBIT key offset     O(1)"></a>13、GETBIT key offset     O(1)</h5><p>返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。    在指定Offset上的BIT值。 </p><h5 id="14、MGET-key-key-…-O-N"><a href="#14、MGET-key-key-…-O-N" class="headerlink" title="14、MGET key [key …]     O(N)"></a>14、MGET key [key …]     O(N)</h5><p>N表示获取Key的数量。返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。    返回一组指定Keys的Values的列表。</p><h5 id="15、MSET-key-value-key-value-…-O-N"><a href="#15、MSET-key-value-key-value-…-O-N" class="headerlink" title="15、MSET key value [key value …]     O(N)"></a>15、MSET key value [key value …]     O(N)</h5><p>N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。     该命令不会失败，始终返回OK。  </p><h5 id="16、MSETNX-key-value-key-value-…-O-N"><a href="#16、MSETNX-key-value-key-value-…-O-N" class="headerlink" title="16、MSETNX key value [key value …]     O(N)"></a>16、MSETNX key value [key value …]     O(N)</h5><p>N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。    1表示所有Keys都设置成功，0则表示没有任何Key被修改。</p><h3 id="三、命令示例："><a href="#三、命令示例：" class="headerlink" title="三、命令示例："></a>三、命令示例：</h3><h5 id="1-SET-GET-APPEND-STRLEN"><a href="#1-SET-GET-APPEND-STRLEN" class="headerlink" title="1. SET/GET/APPEND/STRLEN:"></a>1. SET/GET/APPEND/STRLEN:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/&gt; redis-cli   #执行Redis客户端工具。</span><br><span class="line">redis 127.0.0.1:6379&gt; exists mykey                   #判断该键是否存在，存在返回1，否则返回0。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; append mykey &quot;hello&quot;      #该键并不存在，因此append命令返回当前Value的长度。</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; append mykey &quot; world&quot;    #该键已经存在，因此返回追加后Value的长度。</span><br><span class="line">(integer) 11</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #通过get命令获取该键，以判断append的结果。</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;this is a test&quot; #通过set命令为键设置新值，并覆盖原有值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;this is a test&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; strlen mykey                  #获取指定Key的字符长度，等效于C库中strlen函数。</span><br><span class="line">(integer) 14</span><br></pre></td></tr></table></figure><h5 id="2-INCR-DECR-INCRBY-DECRBY"><a href="#2-INCR-DECR-INCRBY-DECRBY" class="headerlink" title="2. INCR/DECR/INCRBY/DECRBY:"></a>2. INCR/DECR/INCRBY/DECRBY:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set mykey 20     #设置Key的值为20</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey         #该Key的值递增1</span><br><span class="line">(integer) 21</span><br><span class="line">redis 127.0.0.1:6379&gt; decr mykey        #该Key的值递减1</span><br><span class="line">(integer) 20</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey          #删除已有键。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; decr mykey        #对空值执行递减操作，其原值被设定为0，递减后的值为-1</span><br><span class="line">(integer) -1</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey   </span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey        #对空值执行递增操作，其原值被设定为0，递增后的值为1</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey hello #将该键的Value设置为不能转换为整型的普通字符串。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey        #在该键上再次执行递增操作时，Redis将报告错误信息。</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey 10</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; decrby mykey 5 </span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; incrby mykey 10</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure><h5 id="3-GETSET："><a href="#3-GETSET：" class="headerlink" title="3. GETSET："></a>3. GETSET：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    redis 127.0.0.1:6379&gt; incr mycounter      #将计数器的值原子性的递增1</span><br><span class="line">    (integer) 1</span><br><span class="line">    #在获取计数器原有值的同时，并将其设置为新值，这两个操作原子性的同时完成。</span><br><span class="line">    redis 127.0.0.1:6379&gt; getset mycounter 0  </span><br><span class="line">    &quot;1&quot;</span><br><span class="line">    redis 127.0.0.1:6379&gt; get mycounter       #查看设置后的结果。</span><br><span class="line">    &quot;0&quot;</span><br><span class="line">```    </span><br><span class="line"> </span><br><span class="line">##### 4. SETEX:</span><br></pre></td></tr></table></figure><pre><code>redis 127.0.0.1:6379&gt; setex mykey 10 &quot;hello&quot;   #设置指定Key的过期时间为10秒。OK    #通过ttl命令查看一下指定Key的剩余存活时间(秒数)，0表示已经过期，-1表示永不过期。redis 127.0.0.1:6379&gt; ttl mykey                       (integer) 4redis 127.0.0.1:6379&gt; get mykey                      #在该键的存活期内我们仍然可以获取到它的Value。&quot;hello&quot;redis 127.0.0.1:6379&gt; ttl mykey                        #该ttl命令的返回值显示，该Key已经过期。(integer) 0redis 127.0.0.1:6379&gt; get mykey                      #获取已过期的Key将返回nil。(nil)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### 5. SETNX:</span><br></pre></td></tr></table></figure><pre><code>redis 127.0.0.1:6379&gt; del mykey                      #删除该键，以便于下面的测试验证。(integer) 1redis 127.0.0.1:6379&gt; setnx mykey &quot;hello&quot;        #该键并不存在，因此该命令执行成功。(integer) 1redis 127.0.0.1:6379&gt; setnx mykey &quot;world&quot;       #该键已经存在，因此本次设置没有产生任何效果。(integer) 0redis 127.0.0.1:6379&gt; get mykey                      #从结果可以看出，返回的值仍为第一次设置的值。&quot;hello&quot;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### 6. SETRANGE/GETRANGE:</span><br></pre></td></tr></table></figure><pre><code>redis 127.0.0.1:6379&gt; set mykey &quot;hello world&quot;       #设定初始值。OKredis 127.0.0.1:6379&gt; setrange mykey 6 dd          #从第六个字节开始替换2个字节(dd只有2个字节)(integer) 11redis 127.0.0.1:6379&gt; get mykey                         #查看替换后的值。&quot;hello ddrld&quot;redis 127.0.0.1:6379&gt; setrange mykey 20 dd        #offset已经超过该Key原有值的长度了，该命令将会在末尾补0。(integer) 22redis 127.0.0.1:6379&gt; get mykey                           #查看补0后替换的结果。&quot;hello ddrld\x00\x00\x00\x00\x00\x00\x00\x00\x00dd&quot;redis 127.0.0.1:6379&gt; del mykey                         #删除该Key。(integer) 1redis 127.0.0.1:6379&gt; setrange mykey 2 dd         #替换空值。(integer) 4redis 127.0.0.1:6379&gt; get mykey                        #查看替换空值后的结果。&quot;\x00\x00dd&quot;   redis 127.0.0.1:6379&gt; set mykey &quot;0123456789&quot;   #设置新值。OKredis 127.0.0.1:6379&gt; getrange mykey 1 2      #截取该键的Value，从第一个字节开始，到第二个字节结束。&quot;12&quot;redis 127.0.0.1:6379&gt; getrange mykey 1 20   #20已经超过Value的总长度，因此将截取第一个字节后面的所有字节。&quot;123456789&quot;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### 7. SETBIT/GETBIT:</span><br></pre></td></tr></table></figure><pre><code>redis 127.0.0.1:6379&gt; del mykey(integer) 1redis 127.0.0.1:6379&gt; setbit mykey 7 1       #设置从0开始计算的第七位BIT值为1，返回原有BIT值0(integer) 0redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0001的十六进制值为0x01&quot;\x01&quot;redis 127.0.0.1:6379&gt; setbit mykey 6 1       #设置从0开始计算的第六位BIT值为1，返回原有BIT值0(integer) 0redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0011的十六进制值为0x03&quot;\x03&quot;redis 127.0.0.1:6379&gt; getbit mykey 6          #返回了指定Offset的BIT值。(integer) 1redis 127.0.0.1:6379&gt; getbit mykey 10        #Offset已经超出了value的长度，因此返回0。(integer) 0</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### 8. MSET/MGET/MSETNX:</span><br></pre></td></tr></table></figure><pre><code>redis 127.0.0.1:6379&gt; mset key1 &quot;hello&quot; key2 &quot;world&quot;   #批量设置了key1和key2两个键。OKredis 127.0.0.1:6379&gt; mget key1 key2                        #批量获取了key1和key2两个键的值。1) &quot;hello&quot;2) &quot;world&quot;#批量设置了key3和key4两个键，因为之前他们并不存在，所以该命令执行成功并返回1。redis 127.0.0.1:6379&gt; msetnx key3 &quot;stephen&quot; key4 &quot;liu&quot; (integer) 1redis 127.0.0.1:6379&gt; mget key3 key4                   1) &quot;stephen&quot;2) &quot;liu&quot;#批量设置了key3和key5两个键，但是key3已经存在，所以该命令执行失败并返回0。redis 127.0.0.1:6379&gt; msetnx key3 &quot;hello&quot; key5 &quot;world&quot; (integer) 0#批量获取key3和key5，由于key5没有设置成功，所以返回nil。redis 127.0.0.1:6379&gt; mget key3 key5                   1) &quot;stephen&quot;2) (nil)</code></pre><p>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述：&quot;&gt;&lt;a href=&quot;#一、概述：&quot; class=&quot;headerlink&quot; title=&quot;一、概述：&quot;&gt;&lt;/a&gt;一、概述：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;字符串类型是Redis中最为基础
      
    
    </summary>
    
      <category term="redis笔记" scheme="http://www.rxdonny.com/categories/redis%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://www.rxdonny.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>hibernate的缓存</title>
    <link href="http://www.rxdonny.com/2018/03/19/hibernate%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://www.rxdonny.com/2018/03/19/hibernate的缓存/</id>
    <published>2018-03-19T06:48:24.000Z</published>
    <updated>2018-03-19T16:47:01.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是缓存："><a href="#什么是缓存：" class="headerlink" title="什么是缓存："></a>什么是缓存：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存就是将数据库/硬盘上文件中的数据放入到缓存中（就是内存中的一块空间），当再次使用的时候，可以直接从内存中获取。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存的好处：提升程序运行的效率，缓存技术是hibernate的一个优化手段。</p><h3 id="Hibernate缓存的分类"><a href="#Hibernate缓存的分类" class="headerlink" title="Hibernate缓存的分类"></a>Hibernate缓存的分类</h3><p>1.一级缓存：自带的缓存（是session级别的缓存  每一个session都有一个自己的一级缓存），不可以卸载<br>2.二级缓存：二级缓存是由第三方提供 ehcache  oscache（二级缓存是sessionfactory级别的 一个工程只有一个session工厂）<br>    （1）拷二级缓存开发包<br>    （2）总的配置文件开启二级缓存 cache.use_second_level_cache<br>    （3）配置二级缓存的提供者     cache.provider_class<br>    （4）标记使用二级缓存的类     在相应类的配置文件里加<cache usage="nonstrict-read-write"><br>3.查询缓存<br>    只给hql语句使用  hibernate query  language 和sql 相似<br>    （1）配置二级缓存<br>    （2）总的配置文件开启查询缓存   在总的配置文件中 cache.use_query_cache<br>    （3）代码中开启查询缓存</cache></p><h3 id="理解Session缓存（一级缓存）"><a href="#理解Session缓存（一级缓存）" class="headerlink" title="理解Session缓存（一级缓存）"></a>理解Session缓存（一级缓存）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存. 只要 Session 实例没有结束生命周期, 存放在它缓存中的对象也不会结束生命周期</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当session的save()方法持久化一个对象时，该对象被载入缓存，以后即使程序中不再引用该对象，只要缓存不清空，该对象仍然处于生命周期中。当试图get()、 load()对象时，会判断缓存中是否存在该对象，有则返回，此时不查询数据库。没有再查询数据库</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session 能够在某些时间点, 按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库, 这一过程被称为刷出缓存(flush)</p><h3 id="实现hibernate的一级缓存"><a href="#实现hibernate的一级缓存" class="headerlink" title="实现hibernate的一级缓存"></a>实现hibernate的一级缓存</h3><h4 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h4><p>数据库创建三张表：商品表goods(goodsid,goodsname),用户表 userinfo(username,password),收藏表collection(uname,gid)建立主外键关系gid-goodsid,uname-username新建工程，创建Goods，UserInfo类并配置。</p><h4 id="2、编写测试类test1：证明缓存的存在"><a href="#2、编写测试类test1：证明缓存的存在" class="headerlink" title="2、编写测试类test1：证明缓存的存在"></a>2、编写测试类test1：证明缓存的存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> com.pojo.Goods;</span><br><span class="line"><span class="keyword">import</span> com.util.HibernateSessionFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateSessionFactory.getSession();</span><br><span class="line">Goods goods = (Goods) session.get(Goods.class, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//如果 session没有关闭 下面创建的session2 和session  同时指向一个缓存  即  session  和session2  是同一个</span></span><br><span class="line">Session session2 = HibernateSessionFactory.getSession();</span><br><span class="line">Goods goods2 = (Goods) session2.get(Goods.class, <span class="number">1</span>);</span><br><span class="line">System.out.println(goods.getGoodsid()+<span class="string">"\t"</span> + goods.getGoodsname());</span><br><span class="line">System.out.println(goods2.getGoodsid()+<span class="string">"\t"</span> + goods2.getGoodsname());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br><img src="1.png" alt="测试类test1：证明缓存的存在的结果"><br>结果中只有一条SQL语句，并且输出的结果是一样的，说明程序在执行Goods goods2 = (Goods) session2.get(Goods.class, 1);时没有发送SQL语句，返回的结果是从缓存中读取的。</p><h4 id="3、编写测试类test2："><a href="#3、编写测试类test2：" class="headerlink" title="3、编写测试类test2："></a>3、编写测试类test2：</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是缓存：&quot;&gt;&lt;a href=&quot;#什么是缓存：&quot; class=&quot;headerlink&quot; title=&quot;什么是缓存：&quot;&gt;&lt;/a&gt;什么是缓存：&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;缓存就是将数据库/硬盘上
      
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.rxdonny.com/categories/Hibernate/"/>
    
    
      <category term="hibernate" scheme="http://www.rxdonny.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>hibernate多对多关系</title>
    <link href="http://www.rxdonny.com/2018/03/19/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.rxdonny.com/2018/03/19/hibernate多对多关系/</id>
    <published>2018-03-19T06:48:24.000Z</published>
    <updated>2018-03-19T16:05:56.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多对多关系在数据库中是通过建立<strong>中间表</strong>来实现的</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多对多关系在类中的实现方式：在类中不需要编写中间表对应的类，在类中用两个集合来实现中间表。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>数据库创建三张表：商品表goods(goodsid,goodsname),用户表 userinfo(username,password),收藏表collection(uname,gid)建立主外键关系gid-goodsid,uname-username新建工程，创建Goods，UserInfo类并配置。</p><p>###（1）pojo.Goods 类中除了与表goods字段一一对应的变量以外，还定义一个pojo.UserInfo 的对象集合<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> goodsid;</span><br><span class="line"><span class="keyword">private</span> String goodsname;</span><br><span class="line"><span class="comment">// 通过集合来实现中间表</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;UserInfo&gt; infos = <span class="keyword">new</span> HashSet&lt;UserInfo&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;UserInfo&gt; <span class="title">getInfos</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> infos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfos</span><span class="params">(Set&lt;UserInfo&gt; infos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.infos = infos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGoodsid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> goodsid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsid</span><span class="params">(<span class="keyword">int</span> goodsid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.goodsid = goodsid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGoodsname</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> goodsname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsname</span><span class="params">(String goodsname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.goodsname = goodsname;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> （2） 在pojo.Goods的配置文件Goods.hbm.xml进行如下配置</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC <span class="string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- pojo的映射文件  orm --&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span></span>=<span class="string">"com.pojo.Goods"</span> table=<span class="string">"goods"</span>&gt;</span><br><span class="line">&lt;id name=<span class="string">"goodsid"</span> column=<span class="string">"goodsid"</span>&gt;</span><br><span class="line">&lt;generator class="assigned"&gt;&lt;/generator&gt;</span><br><span class="line">&lt;/id&gt;</span><br><span class="line">&lt;property name="goodsname" column="goodsname"&gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 指定中间表  inverse=<span class="string">"true"</span> 表示反转 不负责维护关系  默认<span class="keyword">false</span> --&gt;</span><br><span class="line">&lt;set name=<span class="string">"infos"</span> table=<span class="string">"collection"</span> inverse=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;key column="gid"&gt;&lt;/key&gt;</span><br><span class="line">&lt;many-to-many class="com.pojo.UserInfo" column="uname"&gt;&lt;/many-to-many&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">&lt;/class&gt;</span><br><span class="line"></span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><p> ###（3）pojo.UserInfo 类中除了与表userinfo字段一一对应的变量以外，还定义一个pojo.Goods 的对象集合<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;Goods&gt; goods = <span class="keyword">new</span> HashSet&lt;Goods&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Goods&gt; <span class="title">getGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> goods;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoods</span><span class="params">(Set&lt;Goods&gt; goods)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.goods = goods;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> （2） 在pojo.UserInfo的配置文件UserInfo.hbm.xml进行如下配置<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  &lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC <span class="string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- pojo的映射文件  orm --&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span></span>=<span class="string">"com.pojo.UserInfo"</span> table=<span class="string">"userinfo"</span>&gt;</span><br><span class="line">&lt;id name=<span class="string">"username"</span> column=<span class="string">"username"</span>&gt;</span><br><span class="line">&lt;generator class="assigned"&gt;&lt;/generator&gt;</span><br><span class="line">&lt;/id&gt;</span><br><span class="line">&lt;property name="password" column="password"&gt;&lt;/property&gt;</span><br><span class="line">&lt;!--指定 中间表 --&gt;</span><br><span class="line">&lt;set name=<span class="string">"goods"</span> table=<span class="string">"collection"</span> cascade=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;key column="uname"&gt;&lt;/key&gt;</span><br><span class="line">&lt;many-to-many class="com.pojo.Goods" column="gid"&gt;&lt;/many-to-many&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">&lt;/class&gt;</span><br><span class="line"></span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p><h3 id="测试：创建Test测试类"><a href="#测试：创建Test测试类" class="headerlink" title="测试：创建Test测试类"></a>测试：创建Test测试类</h3><h4 id="（1）在收藏夹中添加一条记录"><a href="#（1）在收藏夹中添加一条记录" class="headerlink" title="（1）在收藏夹中添加一条记录"></a>（1）在收藏夹中添加一条记录</h4><p>思想：<br>1）新增一个用户<br>2）添加一件商品<br>3）session.save()后程序自动在collection中添加一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.Goods;</span><br><span class="line"><span class="keyword">import</span> com.pojo.UserInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">Session session = factory.openSession();</span><br><span class="line"></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  新增一个用户</span></span><br><span class="line">UserInfo info = <span class="keyword">new</span> UserInfo();</span><br><span class="line">info.setUsername(<span class="string">"xiao1"</span>);</span><br><span class="line">info.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  添加一件商品</span></span><br><span class="line">Goods goods = <span class="keyword">new</span> Goods();</span><br><span class="line">goods.setGoodsid(<span class="number">4</span>);</span><br><span class="line">goods.setGoodsname(<span class="string">"手机4"</span>);</span><br><span class="line"><span class="comment">//  操作中间表</span></span><br><span class="line"><span class="comment">//goods.getInfos().add(info);   // 若goods的配置文件Goods.hbm.xml &lt;set&gt;&lt;set/&gt;标签中inverse="true" 则不能实现  添加  即不负责维护关系</span></span><br><span class="line">info.getGoods().add(goods);</span><br><span class="line"><span class="comment">// 下面两条语句顺序不影响结果</span></span><br><span class="line">session.save(info);</span><br><span class="line">session.save(goods);</span><br><span class="line">transaction.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）查询某用户收藏的商品"><a href="#（2）查询某用户收藏的商品" class="headerlink" title="（2）查询某用户收藏的商品"></a>（2）查询某用户收藏的商品</h4><p>思想：<br>1）现在数据库中找到要查询的用户<br>2）根据用户得到其收藏的商品对象集合<br>3）foreach循环输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> com.pojo.Goods;</span><br><span class="line"><span class="keyword">import</span> com.pojo.UserInfo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1_query</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line">Session session = factory.openSession();</span><br><span class="line"><span class="comment">//  查询某个用户收藏的商品</span></span><br><span class="line"><span class="comment">//  先找到想要查询的用户</span></span><br><span class="line">UserInfo info = (UserInfo) session.get(UserInfo.class, <span class="string">"xiaohei"</span>);</span><br><span class="line">Set&lt;Goods&gt; goods = info.getGoods();</span><br><span class="line"><span class="keyword">for</span> (Goods goods2 : goods) &#123;</span><br><span class="line">System.out.println(goods2.getGoodsid()+<span class="string">"\t"</span>+goods2.getGoodsname());</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）清除某用户收藏的一个或商品"><a href="#（3）清除某用户收藏的一个或商品" class="headerlink" title="（3）清除某用户收藏的一个或商品"></a>（3）清除某用户收藏的一个或商品</h4><p>原理：操作中间表其实就是操作集合<br>思想：<br>1）现在数据库中找到要查询的用户info<br>2）根据用户得到其收藏的商品对象集合<br>3）清空：集合.clear();<br>4）清除某一个：找到具体要清除的商品goods，然后 info.getGoods().remove(goods);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> com.pojo.Goods;</span><br><span class="line"><span class="keyword">import</span> com.pojo.UserInfo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 清除某用户收藏的所有商品</span></span><br><span class="line"><span class="comment"> * 原理：在中间表中删除用户x的所有记录</span></span><br><span class="line"><span class="comment"> * 操作： 操作中间表实际就是操作集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2_del</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">Session session = factory.openSession();</span><br><span class="line"></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">UserInfo info = (UserInfo) session.get(UserInfo.class, <span class="string">"小龙"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Goods goods = (Goods) session.get(Goods.class, 1);</span></span><br><span class="line"><span class="comment">//info.getGoods().remove(goods);   删除某一个收藏</span></span><br><span class="line"></span><br><span class="line">info.getGoods().clear(); <span class="comment">// 清空收藏夹</span></span><br><span class="line">session.save(info);</span><br><span class="line">transaction.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;多对多关系在数据库中是通过建立&lt;strong&gt;中
      
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.rxdonny.com/categories/Hibernate/"/>
    
    
      <category term="hibernate" scheme="http://www.rxdonny.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>hibernate一对多关系</title>
    <link href="http://www.rxdonny.com/2018/03/19/hibernate%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.rxdonny.com/2018/03/19/hibernate一对多关系/</id>
    <published>2018-03-19T02:39:24.000Z</published>
    <updated>2018-03-19T16:06:01.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一对多关系在数据库中是通过主外键的形式来实现</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一对多关系在类中有两种实现方式：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）单向关系（效率高）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    该关系由“多”的一方来维护；就是在“多”的一方的pojo中添加“一”的一方的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）双向关系（效率低）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    该关系由“一”的一方来维护；就是在“一”的一方的pojo中添加“多”的一方的对象集合</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>数据库创建两张表：部门表dep(depid,depname),员工表emp(empid,empname,did),建立主外键关系depid-did,新建工程并配置，创建Dep，Emp类。</p><h3 id="1-单向关系——该关系由“多”的一方来维护（emp）"><a href="#1-单向关系——该关系由“多”的一方来维护（emp）" class="headerlink" title="1.单向关系——该关系由“多”的一方来维护（emp）"></a>1.单向关系——该关系由“多”的一方来维护（emp）</h3><p> （1） 在“多”的一方的pojo中添加“一”的一方的对象，在pojo.Emp类中添加如下变量<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> empid;</span><br><span class="line"><span class="keyword">private</span> String empname;</span><br><span class="line"><span class="keyword">private</span> Dep dep ;<span class="comment">// 添加dep的对象   指的是在哪个部门</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dep <span class="title">getDep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDep</span><span class="params">(Dep dep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.dep = dep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEmpid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> empid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpid</span><span class="params">(<span class="keyword">int</span> empid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.empid = empid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmpname</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> empname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpname</span><span class="params">(String empname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.empname = empname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> （2） 在pojo.Emp的配置文件Emp.hbm.xml进行如下配置</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC <span class="string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置的是表和类的关系 --&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span></span>=<span class="string">"com.pojo.Emp"</span> table=<span class="string">"emp"</span>&gt;</span><br><span class="line">&lt;id name=<span class="string">"empid"</span> column=<span class="string">"empid"</span>&gt;</span><br><span class="line">&lt;generator class="assigned"&gt;&lt;/generator&gt;</span><br><span class="line">&lt;/id&gt;</span><br><span class="line">&lt;property name="empname" column="empname"&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 一对多在“多”的一方实现的配置部分 --&gt;</span><br><span class="line">&lt;many-to-one name="dep" column="did" class="com.pojo.Dep" cascade="all"&gt;&lt;/many-to-one&gt;</span><br><span class="line"></span><br><span class="line">&lt;/class&gt;</span><br><span class="line"></span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><h3 id="测试：创建Test测试类"><a href="#测试：创建Test测试类" class="headerlink" title="测试：创建Test测试类"></a>测试：创建Test测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.Emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line">Session session = factory.openSession();</span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">//查询某个员工并得到所在的部门</span></span><br><span class="line">Emp emp = (Emp) session.get(Emp.class, <span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpid() + <span class="string">"\t"</span> + emp.getEmpname() + <span class="string">"\t"</span>+ emp.getDep().getDepname());</span><br><span class="line">transaction.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-单向关系——该关系由“一”的一方来维护（dep）"><a href="#2-单向关系——该关系由“一”的一方来维护（dep）" class="headerlink" title="2.单向关系——该关系由“一”的一方来维护（dep）"></a>2.单向关系——该关系由“一”的一方来维护（dep）</h3><p> （1） 在“一”的一方的pojo中添加“多”的一方的对象集合，在pojo.Dep类中添加如下变量<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depid;</span><br><span class="line"><span class="keyword">private</span> String depname;</span><br><span class="line"><span class="comment">//  添加emp的对象集合  指在该部门下有哪些员工</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Emp&gt; emps = <span class="keyword">new</span> HashSet&lt;Emp&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Emp&gt; <span class="title">getEmps</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmps</span><span class="params">(Set&lt;Emp&gt; emps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.emps = emps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> depid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepid</span><span class="params">(<span class="keyword">int</span> depid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.depid = depid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDepname</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> depname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepname</span><span class="params">(String depname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.depname = depname;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> （2） 在pojo.Dep的配置文件Dep.hbm.xml进行如下配置</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC <span class="string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置的是表和类的关系 --&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span></span>=<span class="string">"com.pojo.Dep"</span> table=<span class="string">"dep"</span>&gt;</span><br><span class="line">&lt;id name=<span class="string">"depid"</span> column=<span class="string">"depid"</span>&gt;</span><br><span class="line">&lt;generator class="assigned"&gt;&lt;/generator&gt;</span><br><span class="line">&lt;/id&gt;</span><br><span class="line">&lt;property name="depname" column="depname"&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 部门有哪些员工  order-by：排序方式  cascade：级联--&gt;</span><br><span class="line">&lt;set name=<span class="string">"emps"</span> order-by=<span class="string">"empid asc"</span> cascade=<span class="string">"save-update"</span>&gt;</span><br><span class="line">&lt;key column="did"&gt;&lt;/key&gt;</span><br><span class="line">&lt;one-to-many <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.pojo.Emp"</span>/&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/class&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><h3 id="测试：创建Test测试类-1"><a href="#测试：创建Test测试类-1" class="headerlink" title="测试：创建Test测试类"></a>测试：创建Test测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.Dep;</span><br><span class="line"><span class="keyword">import</span> com.pojo.Emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">Session session = factory.openSession();</span><br><span class="line"></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line">Dep dep = (Dep) session.get(Dep.class, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Emp&gt; emps = dep.getEmps();</span><br><span class="line">System.out.println(<span class="string">"显示该部门的所有员工："</span>);</span><br><span class="line"><span class="keyword">for</span> (Emp emp2 : emps) &#123;</span><br><span class="line">System.out.println(emp2.getEmpid()+<span class="string">"\t"</span>+emp2.getEmpname()+<span class="string">"\t"</span>+emp2.getDep().getDepname());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">transaction.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h4 id="cascade属性"><a href="#cascade属性" class="headerlink" title="cascade属性"></a>cascade属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在处理一对一、一对多、多对多的关系时，有时会涉及到级联的操作，上面例子中也有体现，即属性cascade：翻译为串联的意思，表示级联操作。级联的意思是：本实体做了什么事，也要拉上另一个关联的实体，导致另一个实体跟着做事情。就是说我删除了，你也得删除！ 关联目标，指的是关联的那个实体。具体的解释可以百度，很详细。</p><p>cascade属性的可能值有<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all: 所有情况下均进行关联操作，即save-update和delete。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; none: 所有情况下均不进行关联操作。这是默认值。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; save-update: 在执行save/update/saveOrUpdate时进行关联操作。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete: 在执行delete 时进行关联操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all-delete-orphan:当一个节点在对象图中成为孤儿节点时，删除该节点。比如在一个一对多的关系中，Student包含多个book，当在对象关系中删除一个book时，此book即成为孤儿节点。</p><h4 id="lazy（懒加载）属性"><a href="#lazy（懒加载）属性" class="headerlink" title="lazy（懒加载）属性"></a>lazy（懒加载）属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 懒加载又称延迟加载，它保证了应用只有在需要时才去数据库中抓取相应的记录。通过延迟加载技术可以避免过多、过早地加载数据表里的数据，从而降低应用的内存开销。Hibernate 的延迟加载本质上就是代理模式的应用，当程序通过 Hibernate 装载一个实体时，默认情况下，Hibernate 并不会立即抓取它的集合属性、关联实体所以对应的记录，而是通过生成一个代理来表示这些集合属性、关联实体，这就是代理模式应用带来的优势。但是，延迟加载也是项目开发中特别常见的一个错误。如果对一个类或者集合配置了延迟检索策略，那么必须当代理类实例或代理集合处于持久化状态（即处于Session范围内）时，才能初始化它。如果在游离状态时才初始化它，就会产生延迟初始化错误。所以，在开发独立的DAO数据访问层时应该格外小心这个问题。</p><p>如果在获取对象的时候使用的是session.get()是不会延迟加载的，只有在使用load、hql时候才会延迟加载。</p><h4 id="session的两种方法-get-load"><a href="#session的两种方法-get-load" class="headerlink" title="session的两种方法  get/load"></a>session的两种方法  get/load</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get和load关系的比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.get是立即加载，不管要不要用这个对象都立马查询；load是懒加载，需要用的时候加载。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.get找不到对象时会返回null；load找不到对象会报错。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.get返回的是pojo对象；load返回的是代理对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一对多关系在数据库中是通过主外键的形式来实现&lt;/
      
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.rxdonny.com/categories/Hibernate/"/>
    
    
      <category term="hibernate" scheme="http://www.rxdonny.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>手动配置hibernate及简单使用规范</title>
    <link href="http://www.rxdonny.com/2018/03/19/%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEhibernate%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://www.rxdonny.com/2018/03/19/手动配置hibernate及简单使用规范/</id>
    <published>2018-03-19T00:35:24.000Z</published>
    <updated>2018-03-19T16:06:23.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录一下手动配置hibernate的过程及操作"><a href="#记录一下手动配置hibernate的过程及操作" class="headerlink" title="记录一下手动配置hibernate的过程及操作"></a>记录一下手动配置hibernate的过程及操作</h1><h2 id="准备工作-三拷三配"><a href="#准备工作-三拷三配" class="headerlink" title="准备工作  三拷三配"></a>准备工作  三拷三配</h2><h3 id="1-三拷；资源在网上都可以找得到"><a href="#1-三拷；资源在网上都可以找得到" class="headerlink" title="1.三拷；资源在网上都可以找得到"></a>1.三拷；资源在网上都可以找得到</h3><p> （1） 拷jdbc驱动，放在“工程/WebRoot/WEB-INF/lib”文件夹下<br> （2） 拷hibernate开发包，放在“工程/WebRoot/WEB-INF/lib”文件夹下<br> （3） 拷log4j，放在“工程/src”文件夹下</p><h3 id="2-三配"><a href="#2-三配" class="headerlink" title="2.三配"></a>2.三配</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如：数据库有表dep（depid，depname）<br> （1） 配置pojo，即配置class，实现class-table一一对应；如：创建Dep类<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depid;</span><br><span class="line"><span class="keyword">private</span> String depname;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> depid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepid</span><span class="params">(<span class="keyword">int</span> depid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.depid = depid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDepname</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> depname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepname</span><span class="params">(String depname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.depname = depname;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> （2） 配置pojo的配置文件,真正实现class-table的一一对应；如：创建Dep.hbm.xml文件，该文件放在同Dep类一个包内（这里是放在pojo包中）；有如下基本配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC <span class="string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置的是orm关系 --&gt;</span><br><span class="line">&lt;!-- 该xml文件   .hbm.xml 前可以改名   这是最容易配置的文件--&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span></span>=<span class="string">"com.pojo.Dep"</span> table=<span class="string">"dep"</span>&gt;&lt;!-- 配置的是表和类的关系 --&gt;</span><br><span class="line">&lt;!-- 主键的配置 --&gt;</span><br><span class="line">&lt;id column=<span class="string">"depid"</span> name=<span class="string">"depid"</span>&gt;</span><br><span class="line">&lt;generator class="assigned"&gt;&lt;/generator&gt;&lt;!-- 自己设计主键 --&gt;</span><br><span class="line">&lt;/id&gt;</span><br><span class="line">&lt;!-- 非主键的配置 --&gt;</span><br><span class="line">&lt;property name="depname" column="depname" length="20"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>（3）配置总的配置文件hibernate.cfg.xml（该文件不可以随意改名）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">'1.0'</span> encoding=<span class="string">'UTF-8'</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">          <span class="string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line">          <span class="string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span><br><span class="line">&lt;!-- 配置的jdbc的参数 --&gt;</span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">&lt;session-factory&gt;</span><br><span class="line">&lt;!-- 设置jdbc访问数据库的<span class="number">4</span>个参数   当要切换使用数据库时只需要修改这个部分就可以了 --&gt;</span><br><span class="line">&lt;property name="connection.username"&gt;sa&lt;/property&gt;&lt;!-- 你的数据库用户名 --&gt;</span><br><span class="line">&lt;property name="connection.password"&gt;sasa&lt;/property&gt;&lt;!-- 你的数据库登录密码 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"connection.driver_class"</span>&gt;&lt;!-- 驱动：各种数据库的驱动不同 --&gt;</span><br><span class="line">com.microsoft.sqlserver.jdbc.SQLServerDriver</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">"connection.url"</span>&gt;&lt;!-- 要使用的数据库名（s53） --&gt;</span><br><span class="line">jdbc:sqlserver:<span class="comment">//127.0.0.1:1433;DatabaseName=s53</span></span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name="show_sql"&gt;true&lt;/property&gt;&lt;!-- 方便起见：必须设置  显示sql --&gt;</span><br><span class="line">&lt;!-- 设置方言 --&gt;</span><br><span class="line">&lt;property name="dialect"&gt;org.hibernate.dialect.SQLServerDialect&lt;/property&gt;</span><br><span class="line">&lt;!-- pojo的映射文件，必加，因为在使用过程中，第一步读取配置文件操作只会读取总的配置文件而不会单独读取pojo的配置文件   --&gt;</span><br><span class="line">&lt;mapping resource=<span class="string">"com/pojo/Dep.hbm.xml"</span> /&gt;</span><br><span class="line">&lt;/session-factory&gt;</span><br><span class="line"></span><br><span class="line">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure></p><h3 id="测试：创建Test测试类"><a href="#测试：创建Test测试类" class="headerlink" title="测试：创建Test测试类"></a>测试：创建Test测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> com.pojo.Dep;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.读取总的配置文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">// 2.创建session工厂</span></span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line"><span class="comment">// 3.得到session 就是对connection对象进行了封装</span></span><br><span class="line">Session session = factory.openSession();</span><br><span class="line"><span class="comment">// 4.开启事务 -- 执行查询操作时可以不开事务</span></span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line">Dep dep = <span class="keyword">new</span> Dep();</span><br><span class="line">dep.setDepid(<span class="number">2</span>);</span><br><span class="line">dep.setDepname(<span class="string">"李四"</span>);</span><br><span class="line"><span class="comment">// 5.持久化</span></span><br><span class="line">session.save(dep);<span class="comment">// 保存</span></span><br><span class="line"><span class="comment">// 6.提交事务</span></span><br><span class="line">transaction.commit();</span><br><span class="line"><span class="comment">// 7.关闭session</span></span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录一下手动配置hibernate的过程及操作&quot;&gt;&lt;a href=&quot;#记录一下手动配置hibernate的过程及操作&quot; class=&quot;headerlink&quot; title=&quot;记录一下手动配置hibernate的过程及操作&quot;&gt;&lt;/a&gt;记录一下手动配置hibernate
      
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.rxdonny.com/categories/Hibernate/"/>
    
    
      <category term="hibernate" scheme="http://www.rxdonny.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Linux-LVS负载均衡之DR方法实现</title>
    <link href="http://www.rxdonny.com/2018/01/03/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8BDR%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.rxdonny.com/2018/01/03/LVS负载均衡之DR方法实现/</id>
    <published>2018-01-03T13:51:24.000Z</published>
    <updated>2018-01-03T14:22:10.852Z</updated>
    
    <content type="html"><![CDATA[<p>实现原理图：<br><img src="1.png" alt="1"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该练习需要三个主机（本人使用的是CentOS6.4版本操作系统），可以通过虚拟机克隆技术克隆另外两个主机，当然，克隆完之后记得更改主机名，便于操作与识别。一台充当LVS服务器（lvs-server:（单网卡：eth0:200.168.10.1））另外两台真实服务器（real-server1（单网卡：200.168.10.2）、real-server2（单网卡：：200.168.10.3））</p><p>（1） 添加虚拟网络VMnet1，设置网段：200.168.10.0 ，子网掩码：255.255.255.0；<br><img src="2.png" alt="2图"><br>（2） vmnet1 win7下设置IP为：200.168.10.4，netmask：255.255.255.0，不需要指定网关<br><img src="3.png" alt="3图"><br>（3） 在Lvsserver安装软件ipvsadm（此步可以提前，需要在NAT网络连接模式开启）：<br>yum  -y  install ipvsadm*<br>（4）使用vmnet1（模拟外网），除了vmnet1之外，其它网络全部关掉（否则有可能会对实验结果造成影响，记住，是有可能！）</p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h4 id="1、配置IP-（均使用vmnet1网段）"><a href="#1、配置IP-（均使用vmnet1网段）" class="headerlink" title="1、配置IP （均使用vmnet1网段）"></a>1、配置IP （均使用vmnet1网段）</h4><p>（1）lvsserver: 配置临时ip(本实验为临时测试)<br>ifconfig  eth0 200.168.10.1 netmask 255.255.255.0<br>（2）real-server1 配置临时ip:<br>ifconfig  eth0 200.168.10.2<br>（3）real-server2 配置临时ip:<br>ifconfig  eth0 200.168.10.3</p><h4 id="2、依次检查防火墙（lvs-server-real-server1-real-server2）"><a href="#2、依次检查防火墙（lvs-server-real-server1-real-server2）" class="headerlink" title="2、依次检查防火墙（lvs-server, real-server1,real-server2）"></a>2、依次检查防火墙（lvs-server, real-server1,real-server2）</h4><p>iptables-L -n (iptables)<br>sestatus(selinux)</p><h4 id="3、在lvs-server上开启路由管道"><a href="#3、在lvs-server上开启路由管道" class="headerlink" title="3、在lvs-server上开启路由管道"></a>3、在lvs-server上开启路由管道</h4><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p><h4 id="4、lvs-server配置"><a href="#4、lvs-server配置" class="headerlink" title="4、lvs-server配置"></a>4、lvs-server配置</h4><h5 id="（1）配置-dr-server"><a href="#（1）配置-dr-server" class="headerlink" title="（1）配置 dr server"></a>（1）配置 dr server</h5><p>ipvsadm-C<br>ipvsadm-At 200.168.10.10:80 -s rr<br>ipvsadm-at 200.168.10.10:80 -r 200.168.10.2:80 -g<br>ipvsadm-at 200.168.10.10:80 -r 200.168.10.3:80 -g<br>ipvsadm-L –n</p><p><img src="7.png" alt="7"> </p><h5 id="（2）DR服务器配置虚拟IP并添加路由"><a href="#（2）DR服务器配置虚拟IP并添加路由" class="headerlink" title="（2）DR服务器配置虚拟IP并添加路由"></a>（2）DR服务器配置虚拟IP并添加路由</h5><p>1) ifconfig lo:0 200.168.10.10 netmask 255.255.255.255 up<br>2) route add -host 200.168.10.10 dev lo:0</p><h4 id="5、分别配置两个真实服务器real-server1-real-server2"><a href="#5、分别配置两个真实服务器real-server1-real-server2" class="headerlink" title="5、分别配置两个真实服务器real-server1,real-server2"></a>5、分别配置两个真实服务器real-server1,real-server2</h4><p>ifconfig lo:0 200.168.10.10 netmask255.255.255.255 up<br>route add -host 200.168.10.10 dev lo:0<br>route -n （查看:real-server2为例）</p><p><img src="4.png" alt="4"></p><p>两台服务器继续配置：</p><p>echo 1 &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore<br>echo 2 &gt;/proc/sys/net/ipv4/conf/lo/arp_announce<br>echo 1 &gt;/proc/sys/net/ipv4/conf/all/arp_ignore<br>echo 2 &gt;/proc/sys/net/ipv4/conf/all/arp_announce</p><h4 id="6、添加HTML用于测试显示"><a href="#6、添加HTML用于测试显示" class="headerlink" title="6、添加HTML用于测试显示"></a>6、添加HTML用于测试显示</h4><p>（1) 在real-server1设置<br>service httpd restart<br>cd /var/www/html/<br>echo “&lt;h1&gt; &lt;font color=’red’&gt;lvs之dr：200.168.10.2 &lt;/font&gt;     &lt;/h1&gt;” &gt; index.html<br>（2)在real-server2设置<br>service httpd restart<br>cd /var/www/html/<br>echo “&lt;h1&gt; &lt;font color=’blue’&gt;lvs之dr：200.168.10.3 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开Windows浏览器，在地址栏输入200.168.10.10,回车，显示内容为下图<br><img src="8.png" alt="8"><br>或者<br><img src="9.png" alt="9"></p><p>当点击<strong>刷新</strong>按钮时会显示另外一个网页。</p><p>完毕！谢谢浏览！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现原理图：&lt;br&gt;&lt;img src=&quot;1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;
      
    
    </summary>
    
      <category term="Linux-LVS" scheme="http://www.rxdonny.com/categories/Linux-LVS/"/>
    
    
      <category term="Linux-LVS" scheme="http://www.rxdonny.com/tags/Linux-LVS/"/>
    
      <category term="VS/DR" scheme="http://www.rxdonny.com/tags/VS-DR/"/>
    
  </entry>
  
  <entry>
    <title>Linux-LVS负载均衡之TUN（隧道技术）方法实现</title>
    <link href="http://www.rxdonny.com/2018/01/03/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8BTUN%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.rxdonny.com/2018/01/03/LVS负载均衡之TUN方法实现/</id>
    <published>2018-01-03T13:19:33.000Z</published>
    <updated>2018-01-03T14:21:39.617Z</updated>
    
    <content type="html"><![CDATA[<p>实现原理图：<br><img src="1.png" alt="1"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该练习需要三个主机（本人使用的是CentOS6.4版本操作系统），可以通过虚拟机克隆技术克隆另外两个主机，当然，克隆完之后记得更改主机名，便于操作与识别。一台充当LVS服务器（lvs-server:（单网卡：eth0:200.168.10.1））另外两台真实服务器（real-server1（单网卡：200.168.10.2）、real-server2（单网卡：：200.168.10.3））</p><p>（1） 添加虚拟网络VMnet1，设置网段：200.168.10.0 ，子网掩码：255.255.255.0；<br><img src="2.png" alt="2图"><br>（2） vmnet1 win7下设置IP为：200.168.10.4，netmask：255.255.255.0，不需要指定网关<br><img src="3.png" alt="3图"><br>（3） 在Lvsserver安装软件ipvsadm（此步可以提前，需要在NAT网络连接模式开启）：<br>yum  -y install ipvsadm*<br>（4）使用vmnet1（模拟外网），除了vmnet1之外，其它网络全部关掉（否则有可能会对实验结果造成影响，记住，是有可能！）</p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h4 id="1、配置IP-（均使用vmnet1网段）"><a href="#1、配置IP-（均使用vmnet1网段）" class="headerlink" title="1、配置IP （均使用vmnet1网段）"></a>1、配置IP （均使用vmnet1网段）</h4><p>（1）lvsserver: 配置临时ip(本实验为临时测试)<br>ifconfig  eth0 200.168.10.1 netmask 255.255.255.0<br>（2）real-server1 配置临时ip:<br>ifconfig  eth0 200.168.10.2<br>（3）real-server2 配置临时ip:<br>ifconfig  eth0 200.168.10.3</p><h4 id="2、依次检查防火墙（lvs-server-real-server1-real-server2）"><a href="#2、依次检查防火墙（lvs-server-real-server1-real-server2）" class="headerlink" title="2、依次检查防火墙（lvs-server, real-server1,real-server2）"></a>2、依次检查防火墙（lvs-server, real-server1,real-server2）</h4><p>iptables-L -n (iptables)<br>sestatus(selinux)</p><h4 id="3、在lvs-server上开启路由管道"><a href="#3、在lvs-server上开启路由管道" class="headerlink" title="3、在lvs-server上开启路由管道"></a>3、在lvs-server上开启路由管道</h4><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p><h4 id="4、lvs-server配置"><a href="#4、lvs-server配置" class="headerlink" title="4、lvs-server配置"></a>4、lvs-server配置</h4><h5 id="（1）配置-ipmServer"><a href="#（1）配置-ipmServer" class="headerlink" title="（1）配置 ipmServer"></a>（1）配置 ipmServer</h5><p>ipvsadm -C<br>ipvsadm -A -t 200.168.10.10:80 -s rr<br>ipvsadm -at 200.168.10.10:80 -r 200.168.10.2:80 -i<br>ipvsadm -at 200.168.10.10:80 -r 200.168.10.3:80 -i<br>ipvsadm -L –n<br><img src="7.png" alt="7"> </p><h5 id="（2）配置虚拟IP"><a href="#（2）配置虚拟IP" class="headerlink" title="（2）配置虚拟IP"></a>（2）配置虚拟IP</h5><p>1） ifconfig tunl0 200.168.10.10 netmask 255.255.255.255 up   //虚拟一个隧道IP  4个255代表它自己一个网段<br>2） route add -host 200.168.10.10 dev tunl0   //把网段 添加到路由表 防止走 200.168.10.0 网段<br>route -n查看<br><img src="4.png" alt="4"></p><h4 id="5、分别配置两个真实服务器real-server1-real-server2"><a href="#5、分别配置两个真实服务器real-server1-real-server2" class="headerlink" title="5、分别配置两个真实服务器real-server1,real-server2"></a>5、分别配置两个真实服务器real-server1,real-server2</h4><p>ifconfig tunl0  200.168.10.10 netmask 255.255.255.255 up<br>route add –host  200.168.10.10 dev tunl0<br>echo “1” &gt; /proc/sys/net/ipv4/conf/tunl0/arp_ignore<br>echo “2” &gt; /proc/sys/net/ipv4/conf/tunl0/arp_announce<br>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_ignore<br>echo “2” &gt; /proc/sys/net/ipv4/conf/all/arp_announce</p><p>PS：如果ping 200.168.10.10能通，但是网页浏览不通。<br>解决方法：分别在真实机运行下面命令<br>echo “0” &gt; /proc/sys/net/ipv4/conf/tunl0/rp_filter</p><h4 id="6、添加HTML用于测试显示"><a href="#6、添加HTML用于测试显示" class="headerlink" title="6、添加HTML用于测试显示"></a>6、添加HTML用于测试显示</h4><p>（1) 在real-server1设置<br>service httpd restart<br>cd /var/www/html/<br>echo “&lt;h1&gt; &lt;font color=’red’&gt;200.168.10.2 &lt;/font&gt;     &lt;/h1&gt;” &gt; index.html<br>（2)在real-server2设置<br>service httpd restart<br>cd /var/www/html/<br>echo “&lt;h1&gt; &lt;font color=’blue’&gt;200.168.10.3 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开Windows浏览器，在地址栏输入200.168.10.10,回车，显示内容为下图<br><img src="8.png" alt="8"><br>或者<br><img src="9.png" alt="9"></p><p>当点击<strong>刷新</strong>按钮时会显示另外一个网页。</p><p>完毕！谢谢浏览！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现原理图：&lt;br&gt;&lt;img src=&quot;1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;
      
    
    </summary>
    
      <category term="Linux-LVS" scheme="http://www.rxdonny.com/categories/Linux-LVS/"/>
    
    
      <category term="Linux-LVS" scheme="http://www.rxdonny.com/tags/Linux-LVS/"/>
    
      <category term="VS/TUN" scheme="http://www.rxdonny.com/tags/VS-TUN/"/>
    
  </entry>
  
  <entry>
    <title>Linux-LVS负载均衡之NAT方法实现</title>
    <link href="http://www.rxdonny.com/2018/01/03/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8BNAT%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.rxdonny.com/2018/01/03/LVS负载均衡之NAT方法实现/</id>
    <published>2018-01-03T12:22:23.000Z</published>
    <updated>2018-01-03T14:21:57.731Z</updated>
    
    <content type="html"><![CDATA[<p>实现原理图：<br><img src="1.png" alt="vs/nat"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该练习需要三个主机（本人使用的是CentOS6.4版本操作系统），可以通过虚拟机克隆技术克隆另外两个主机，当然，克隆完之后记得更改主机名，便于操作与识别。一台充当LVS服务器（lvs-server:（双网卡：eth0:8.8.8.8 eth1:192.168.10.1））另外两台真实服务器（real-server1（单网卡：192.168.10.2）、real-server2（单网卡：：192.168.10.3））</p><p>（1） 添加虚拟网络VMnet1，设置网段：8.8.8.0 ，子网掩码：255.255.255.0；添加虚拟网络VMnet2，设置网段：192.168.10.0，子网掩码：255.255.255.0<br><img src="2.png" alt="2图"><br>（2） vmnet1 win7下设置IP为：8.8.8.1，netmask：255.255.255.0，不需要指定网关<br><img src="3.png" alt="3图"><br>（3） 在Lvsserver安装软件ipvsadm（此步可以提前，需要在NAT网络连接模式开启）：<br>yum -y install ipvsadm*<br>（4）使用vmnet1（模拟外网），vmnet2（模拟内网），除了vmnet1之外，其它网络全部关掉（否则有可能会对实验结果造成影响，记住，是有可能！）<br>（5） lvs-server 配置两块网卡：<br><img src="4.png" alt="4图"></p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h4 id="1、配置IP"><a href="#1、配置IP" class="headerlink" title="1、配置IP"></a>1、配置IP</h4><p>（1）lvsserver: 配置临时ip(本实验为临时测试)<br>ifconfig  eth0 8.8.8.8 netmask255.255.255.0<br>ifconfig  eth1 192.168.10.1 netmask255.255.255.0<br>（2）real-server1 配置临时ip:<br>ifconfig  eth0 192.168.10.2<br>（3）real-server2 配置临时ip:<br>ifconfig  eth0 192.168.10.3</p><h4 id="2、依次检查防火墙（lvs-server-real-server1-real-server2）"><a href="#2、依次检查防火墙（lvs-server-real-server1-real-server2）" class="headerlink" title="2、依次检查防火墙（lvs-server, real-server1,real-server2）"></a>2、依次检查防火墙（lvs-server, real-server1,real-server2）</h4><p>iptables-L -n (iptables)<br>sestatus(selinux)</p><h4 id="3、real-server1-real-server2分别指定默认网关"><a href="#3、real-server1-real-server2分别指定默认网关" class="headerlink" title="3、real-server1,real-server2分别指定默认网关"></a>3、real-server1,real-server2分别指定默认网关</h4><p>route add default gw 192.168.10.1<br>route -n (查看)<br><img src="5.png" alt="5"><br><img src="6.png" alt="6"></p><h4 id="4、在lvs-server上开启路由管道"><a href="#4、在lvs-server上开启路由管道" class="headerlink" title="4、在lvs-server上开启路由管道"></a>4、在lvs-server上开启路由管道</h4><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p><h4 id="5、添加HTML用于测试显示"><a href="#5、添加HTML用于测试显示" class="headerlink" title="5、添加HTML用于测试显示"></a>5、添加HTML用于测试显示</h4><p>（1) 在real-server1设置<br>service httpd restart<br>cd /var/www/html/<br>echo “&lt;h1&gt; &lt;font color=’red’&gt;192.168.10.2 &lt;/font&gt;     &lt;/h1&gt;” &gt; index.html<br>（2)在real-server2设置<br>service httpd restart<br>cd /var/www/html/<br>echo “&lt;h1&gt; &lt;font color=’blue’&gt;192.168.10.3 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html </p><h4 id="6、配置-ipmServer，即在lvs-server上进行配置"><a href="#6、配置-ipmServer，即在lvs-server上进行配置" class="headerlink" title="6、配置 ipmServer，即在lvs-server上进行配置"></a>6、配置 ipmServer，即在lvs-server上进行配置</h4><p>ipvsadm-C<br>ipvsadm-At 8.8.8.8:80 -s rr<br>ipvsadm-at 8.8.8.8:80 -r 192.168.10.2:80 -m<br>ipvsadm-at 8.8.8.8:80 -r 192.168.10.3:80 -m<br>ipvsadm-L –n （查看）<br><img src="7.png" alt="7"> </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开Windows浏览器，在地址栏输入8.8.8.8,回车，显示内容为下图<br><img src="8.png" alt="8"><br>或者<br><img src="9.png" alt="9"></p><p>当点击<strong>刷新</strong>按钮时会显示另外一个网页。</p><p>完毕！谢谢浏览！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现原理图：&lt;br&gt;&lt;img src=&quot;1.png&quot; alt=&quot;vs/nat&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;n
      
    
    </summary>
    
      <category term="Linux-LVS" scheme="http://www.rxdonny.com/categories/Linux-LVS/"/>
    
    
      <category term="Linux-LVS" scheme="http://www.rxdonny.com/tags/Linux-LVS/"/>
    
      <category term="VS/NAT" scheme="http://www.rxdonny.com/tags/VS-NAT/"/>
    
  </entry>
  
</feed>
