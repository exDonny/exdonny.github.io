[{"title":"代理模式--JDK动态代理的原理及实现","date":"2018-06-01T09:07:24.000Z","path":"2018/06/01/JDK动态代理/","text":"什么是代理模式来自于菜鸟教程的解释：在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 代理模式的实现步骤在使用代理模式时，我们需要在调用者代用对象之前生成一个代理对象，而这个代理对象需要跟真实对象建立代理关系，所以代理必须分为两步：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代理对象和真实对象建立关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实现代理对象的代理逻辑方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在java中有很多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的有两种：一种是JDK动态代理，这是JDK自带的功能；另一种是CGLIB，这是第三方提供的一个技术。在JDK动态代理中，我们需要使用接口，而CGLIB不用。 实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK动态代理是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象，所以我们先定义一个接口HelloWord：1234public interface HelloWord &#123; public void sayHelloWord();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后提供实现类HelloWordImpl来实现接口HelloWord：12345678public class HelloWordImpl implements HelloWord &#123; @Override public void sayHelloWord() &#123; System.out.println(\"Hello Word!\"); &#125;&#125; 此时我们要建立一个实现代理逻辑类JdkProxyExample；按照我们之前的描述，实现动态代理先要建立起代理对象和真实服务对象的关系，然后实现代理逻辑；在JDK动态代理中，要实现代理逻辑类必须去实现java.lang.reflect.InvocationHandler接口，它里面定义了一个invoke方法，并提供接口数组用于下挂代理对象（测试时使用了JUnit4）：123456789101112131415161718192021222324252627282930313233343536373839404142import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import org.junit.Test;public class JdkProxyExample implements InvocationHandler&#123; // 真实对象 private Object target = null; //第一步：建立代理对象和真实对象的代理关系，并返回代理对象 public Object bind(Object target) &#123; // 此时的 target是一个真实的对象 ，通过真实对象返回一个代理对象 this.target = target; /* * 第一个参数：是类加载器 * 第二个参数：将生成的代理的对象下挂在哪些接口下 * 第三个参数：定义实现方法逻辑的代理类 * */ return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; // 第二步：实现代理逻辑方法 // 实现java.lang.reflect.InvocationHandler接口的invoke方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"进入代理逻辑方法\"); System.out.println(\"在调度真实对象之前的服务\"); Object object = method.invoke(target, args);// 相当于调用了sayHelloWord(); System.out.println(\"在调度真实对象之后的服务\"); return object; &#125; // 测试方法 @Test public void testJdkProxy() &#123; JdkProxyExample jdk = new JdkProxyExample(); // 绑定关系，因为是挂在接口HelloWord下，所以声明HelloWord proxy HelloWord proxy = (HelloWord) jdk.bind(new HelloWordImpl()); // 此时proxy对象已经是一个代理对象，当它调用方法时会进入代理的逻辑方法invoke（）中 proxy.sayHelloWord(); &#125;&#125; 第一步：建立代理对象和真实对象的关系。这里是使用了bind方法完成，方法里首先用类的属性target保存了真实对象，然后通过下面的代码建立并返回代理对象：Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);其中newProxyInstance方法包含了3个参数。 第1个是类加载器，我们使用target自身的加载器； 第2个是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在target实现的接口下。即HelloWord接口 第3个是定义实现代理逻辑方法的实现类，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，它就是代理逻辑方法的实现方法。 第二步：实现代理逻辑方法。invoke方法的3个参数： proxy，代理对象，就是bind方法生成的对象（返回的对象）。 method，当前调度的方法。 args，调度方法的参数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用了代理对象调度方法后，它就会进入到invoke方法里面测试结果： 进入代理逻辑方法在调度真实对象之前的服务Hello Word!在调度真实对象之后的服务","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.rxdonny.com/tags/设计模式/"}]},{"title":"JUnit单元测试框架","date":"2018-05-27T15:27:24.000Z","path":"2018/05/27/JUnit/","text":"JUnit的运行流程在myeclipse中创建一个JUnit test case依次选中下面四个方法生成并修改为如下代码1234567891011121314151617181920212223242526272829303132333435363738package com.util;import static org.junit.Assert.*;import org.junit.After;import org.junit.AfterClass;import org.junit.Before;import org.junit.BeforeClass;import org.junit.Test;public class JUnit &#123; @BeforeClass public static void setUpBeforeClass() throws Exception &#123; System.out.println(\"This is BeforeClass ...\"); &#125; @AfterClass public static void tearDownAfterClass() throws Exception &#123; System.out.println(\"This is AfterClass ...\"); &#125; @Before public void setUp() throws Exception &#123; System.out.println(\"This is Before ...\"); &#125; @After public void tearDown() throws Exception &#123; System.out.println(\"This is After ...\"); &#125; @Test public void test1() &#123; System.out.println(\"This is test1 ...\"); &#125; @Test public void test2() &#123; System.out.println(\"This is test2 ...\"); &#125;&#125; 运行结果：12345678This is BeforeClass ...This is Before ...This is test1 ...This is After ...This is Before ...This is test2 ...This is After ...This is AfterClass ... 总结1.@BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法是静态的，所以放测试类被加载后接着就会运行它，它在内存中只会存在一份实例，比较适合加载配置文件或只被执行一次的文件。2.@AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库连接。3.@Before和@After会在每个测试方法的前后各执行一次。 JUnit的常用注解除了上上面的五种注解外还介绍下面几种：1.@Ignore ：所修饰的方法会被测试运行器忽略2.@RunWith：可以更改测试运行器（如测试套件的使用）","tags":[{"name":"Junit","slug":"Junit","permalink":"http://www.rxdonny.com/tags/Junit/"}]},{"title":"linux安装jdk出现 bad ELF interpreter 没有那个文件或目录","date":"2018-05-17T03:27:24.000Z","path":"2018/05/17/linux安装jdk后出现bad ELF interpreter 没有那个文件或目录/","text":"记录在项目中遇到的问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置完环境变量后用java -version测试出现“bash: ./java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录”，网上搜了下，用sudo yum install glibc.i686命令安装好glibc之后就ok。","tags":[{"name":"linux","slug":"linux","permalink":"http://www.rxdonny.com/tags/linux/"}]},{"title":"前端js阻止事件冒泡","date":"2018-04-21T12:27:24.000Z","path":"2018/04/21/前端js阻止事件冒泡/","text":"记录在项目中遇到的问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.event.stopPropagation()方法 这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开， 2.event.preventDefault()方法 这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素； html1234567891011121314151617181920212223&lt;ul class=\"mui-table-view\"&gt; &lt;li class=\"mui-table-view-cell mui-media\" onclick=\"ligo(this,1)\" style=\"color: blue;\"&gt; &lt;span&gt;飞速洗车&lt;/span&gt; &lt;button type=\"button\" class=\"mui-btn mui-btn-primary\"style=\"float: right;\" onclick=\"btngo(this,5)\"&gt; 立即预约 &lt;/button&gt; &lt;/li&gt; &lt;li class=\"mui-table-view-cell mui-media\" onclick=\"ligo(this,1)\" style=\"color: blue;\"&gt; &lt;span&gt;换机油&lt;/span&gt; &lt;button type=\"button\" class=\"mui-btn mui-btn-primary\"style=\"float: right;\" onclick=\"btngo(this,5)\"&gt; 立即预约 &lt;/button&gt; &lt;/li&gt; &lt;li class=\"mui-table-view-cell mui-media\" onclick=\"ligo(this,1)\" style=\"color: blue;\"&gt; &lt;span&gt;来了来了&lt;/span&gt; &lt;button type=\"button\" class=\"mui-btn mui-btn-primary\"style=\"float: right;\" onclick=\"btngo(this,5)\"&gt; 立即预约 &lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; js1234567891011121314151617&lt;script&gt; function ligo(a,sum) &#123; // 跳转服务详情界面 alert(a.tagName+\"\\t\"+sum); &#125; function btngo(a,sum) &#123; // 跳转预约界面 event.stopPropagation();// 阻止冒泡 alert(a.tagName+\"\\t\"+sum); &#125; &lt;/script&gt;","tags":[{"name":"js","slug":"js","permalink":"http://www.rxdonny.com/tags/js/"}]},{"title":"Timestamp类型时间加一天、一个月、一年...","date":"2018-04-19T12:17:24.000Z","path":"2018/04/19/timestamp类型时间的加减/","text":"记录在项目中遇到的问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景：mysql数据库中有张user表，表中有一个overdue字段，字段类型为Timestamp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Do what：java中根据用户ID将该用户的overdue取出，加一年后修改user表中的overdue。 解决问题：方法一：暴力…123456789101112131415161718192021222324package com.test;import java.sql.Timestamp;public class timestample &#123; public static void main(String[] args) &#123; //获取当前时间 Timestamp timestamp = new Timestamp(System.currentTimeMillis()); // 将Timestamp 转换成long类型进行加减再转换成Timestamp //加一天 long time=timestamp.getTime()+(long)1000*3600*24; //加一个月 注：一个月按30天算 long time3 =timestamp.getTime()+(long)1000*3600*24*30; //加一年 long time4 =timestamp.getTime()+(long)1000*3600*24*365; Timestamp timestamp2 =new Timestamp(time); Timestamp timestamp3 =new Timestamp(time3); Timestamp timestamp4 =new Timestamp(time4); // 转回Timestamp System.out.println(\"当前时间：\"+timestamp); System.out.println(\"加上一天：\"+timestamp2); System.out.println(\"加一个月：\"+timestamp3); System.out.println(\"加上一年：\"+timestamp4); &#125;&#125; 运行结果： 方法一：我转…使用Calendar类1、java中将overdue取出，用TimeStamp 类型的变量接收timestamp；2、实例化一个Calendar类的实例3、将timestamp转换为Calendar4、进行加减操作5、转回TimeStamp 类型1234567891011121314151617package com.test;import java.sql.Timestamp;import java.util.Calendar;public class timestample &#123; public static void main(String[] args) &#123; //获取当前时间 Timestamp timestamp0 = new Timestamp(System.currentTimeMillis()); Calendar c = Calendar.getInstance(); c.setTime(timestamp0); //c.add(Calendar.DATE, 1); // 加一 天 //c.add(Calendar.MONTH, 1); // 加一个月 c.add(Calendar.YEAR,1); // 加一 年 Timestamp time1 = new Timestamp(c.getTimeInMillis()); System.out.println(time1); &#125;&#125;","tags":[{"name":"Timestamp","slug":"Timestamp","permalink":"http://www.rxdonny.com/tags/Timestamp/"}]},{"title":"spring中<contextcomponent-scan>的简单使用","date":"2018-04-19T02:47:24.000Z","path":"2018/04/19/spring中contextcomponent-scan的简单使用 /","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用spring进行开发时，我们常常会配置标签。如:12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;!-- 扫描 --&gt; &lt;context:component-scan base-package=\"com.action\"&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 配置完成后，spring就会去自动扫描base-package对应的路径或者该路径的子包下面的java文件（如：com.action包下的所有类），如果扫描到文件中带有@Service,@Component,@Repository,@Controller等这些注解的类，则把这些类注册为bean，就不需要开发人员再去applicationContext.xml中手动配置com.action包中的类的bean以及一些依赖。","tags":[{"name":"spring","slug":"spring","permalink":"http://www.rxdonny.com/tags/spring/"}]},{"title":"redis事务","date":"2018-04-12T10:47:24.000Z","path":"2018/04/12/redis--事务/","text":"一、概述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征： 1). 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。2). 和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。3). 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。4). 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。5). 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。 二、相关命令（O表示时间复杂度）MULTI用于标记事务的开始，其后执行的命令都将被存入命令队列，直到执行EXEC时，这些命令才会被原子的执行。 始终返回OK EXEC执行在一个事务内命令队列中的所有命令，同时将当前连接的状态恢复为正常状态，即非事务状态。如果在事务中执行了WATCH命令，那么只有当WATCH所监控的Keys没有被修改的前提下，EXEC命令才能执行事务队列中的所有命令，否则EXEC将放弃当前事务中的所有命令。 原子性的返回事务中各条命令的返回结果。如果在事务中使用了WATCH，一旦事务被放弃，EXEC将返回NULL-multi-bulk回复。 DISCARD回滚事务队列中的所有命令，同时再将当前连接的状态恢复为正常状态，即非事务状态。如果WATCH命令被使用，该命令将UNWATCH所有的Keys。 始终返回OK。 WATCH key [key …] O(1)在MULTI命令执行之前，可以指定待监控的Keys，然而在执行EXEC之前，如果被监控的Keys发生修改，EXEC将放弃执行该事务队列中的所有命令。 始终返回OK。 UNWATCH O(1)取消当前事务中指定监控的Keys，如果执行了EXEC或DISCARD命令，则无需再手工执行该命令了，因为在此之后，事务中所有被监控的Keys都将自动取消。 始终返回OK。 三、命令示例：1. 事务被正常执行：123456789101112131415#在Shell命令行下执行Redis的客户端工具。 /&gt; redis-cli #在当前连接上启动一个新的事务。 redis 127.0.0.1:6379&gt; multi OK #执行事务中的第一条命令，从该命令的返回结果可以看出，该命令并没有立即执行，而是存于事务的命令队列。 redis 127.0.0.1:6379&gt; incr t1 QUEUED #又执行一个新的命令，从结果可以看出，该命令也被存于事务的命令队列。 redis 127.0.0.1:6379&gt; incr t2 QUEUED #执行事务命令队列中的所有命令，从结果可以看出，队列中命令的结果得到返回。 redis 127.0.0.1:6379&gt; exec 1) (integer) 1 2) (integer) 1 2. 事务中存在失败的命令：123456789101112131415161718192021#开启一个新的事务。redis 127.0.0.1:6379&gt; multiOK#设置键a的值为string类型的3。redis 127.0.0.1:6379&gt; set a 3QUEUED#从键a所关联的值的头部弹出元素，由于该值是字符串类型，而lpop命令仅能用于List类型，因此在执行exec命令时，该命令将会失败。redis 127.0.0.1:6379&gt; lpop aQUEUED#再次设置键a的值为字符串4。redis 127.0.0.1:6379&gt; set a 4QUEUED#获取键a的值，以便确认该值是否被事务中的第二个set命令设置成功。redis 127.0.0.1:6379&gt; get aQUEUED#从结果中可以看出，事务中的第二条命令lpop执行失败，而其后的set和get命令均执行成功，这一点是Redis的事务与关系型数据库中的事务之间最为重要的差别。redis 127.0.0.1:6379&gt; exec1) OK2) (error) ERR Operation against a key holding the wrong kind of value3) OK4) &quot;4&quot; 3.回滚事务：123456789101112131415 #为键t2设置一个事务执行前的值。redis 127.0.0.1:6379&gt; set t2 ttOK#开启一个事务。redis 127.0.0.1:6379&gt; multiOK#在事务内为该键设置一个新值。redis 127.0.0.1:6379&gt; set t2 ttnewQUEUED#放弃事务。redis 127.0.0.1:6379&gt; discardOK#查看键t2的值，从结果中可以看出该键的值仍为事务开始之前的值。redis 127.0.0.1:6379&gt; get t2&quot;tt&quot; 四、WATCH命令和基于CAS的乐观锁：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：val = GET mykeyval = val + 1SET mykey $val&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景–竞态争用(race condition)。比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：WATCH mykeyval = GET mykeyval = val + 1MULTISET mykey $valEXEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。","tags":[{"name":"redis","slug":"redis","permalink":"http://www.rxdonny.com/tags/redis/"}]},{"title":"redis数据类型-Sorted-Sets","date":"2018-04-12T08:57:24.000Z","path":"2018/04/12/redis--Sorted-Sets类型/","text":"一、概述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。 二、相关命令（O表示时间复杂度）ZADD key score member [score] [member] O(log(N))时间复杂度中的N表示Sorted-Sets中成员的数量。添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。如果该键已经存在，但是与其关联的Value不是Sorted-Sets类型，相关的错误信息将被返回。 本次操作实际插入的成员数量。 ZCARD key O(1)获取与该Key相关联的Sorted-Sets中包含的成员数量。 返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。 ZCOUNT key min max O(log(N)+M)该命令用于获取分数(score)在min和max之间的成员数量。针对min和max参数需要额外说明的是，-inf和+inf分别表示Sorted-Sets中分数的最高值和最低值。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。 分数指定范围内成员的数量。 ZINCRBY key increment member O(log(N))该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。如果与该Key关联的不是Sorted-Sets类型，相关的错误信息将被返回。 以字符串形式表示的新分数。 ZRANGE key start stop [WITHSCORES] O(log(N)+M)时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令返回顺序在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。 返回索引在start和stop之间的成员列表。 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] O(log(N)+M)该命令将返回分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。可选参数WITHSCORES的含义参照ZRANGE中该选项的说明。最后需要说明的是参数中min和max的规则可参照命令ZCOUNT。 返回分数在指定范围内的成员列表。 ZRANK key member O(log(N))时间复杂度中的N表示Sorted-Set中成员的数量。Sorted-Set中的成员都是按照分数从低到高的顺序存储，该命令将返回参数中指定成员的位置值，其中0表示第一个成员，它是Sorted-Set中分数最低的成员。 如果该成员存在，则返回它的位置索引值。否则返回nil。 ZREM key member [member …] O(M log(N))时间复杂度中N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。 实际被删除的成员数量。 ZREVRANGE key start stop [WITHSCORES] O(log(N)+M)时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令的功能和ZRANGE基本相同，唯一的差别在于该命令是通过反向排序获取指定位置的成员，即从高到低的顺序。如果成员具有相同的分数，则按降序字典顺序排序。 返回指定的成员列表。 ZREVRANK key member O(log(N))时间复杂度中的N表示Sorted-Set中成员的数量。该命令的功能和ZRANK基本相同，唯一的差别在于该命令获取的索引是从高到低排序后的位置，同样0表示第一个元素，即分数最高的成员。 如果该成员存在，则返回它的位置索引值。否则返回nil。 ZSCORE key member O(1)获取指定Key的指定成员的分数。 如果该成员存在，以字符串的形式返回其分数，否则返回nil。 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] O(log(N)+M)时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。 返回分数在指定范围内的成员列表。 ZREMRANGEBYRANK key start stop O(log(N)+M)时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。 被删除的成员数量。 ZREMRANGEBYSCORE key min max O(log(N)+M)时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。 被删除的成员数量。 三、命令示例：1. ZADD/ZCARD/ZCOUNT/ZREM/ZINCRBY/ZSCORE/ZRANGE/ZRANK:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#在Shell的命令行下启动Redis客户端工具。 /&gt; redis-cli #添加一个分数为1的成员。 redis 127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; (integer) 1 #添加两个分数分别是2和3的两个成员。 redis 127.0.0.1:6379&gt; zadd myzset 2 &quot;two&quot; 3 &quot;three&quot; (integer) 2 #0表示第一个成员，-1表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员。 redis 127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES 1) &quot;one&quot; 2) &quot;1&quot; 3) &quot;two&quot; 4) &quot;2&quot; 5) &quot;three&quot; 6) &quot;3&quot; #获取成员one在Sorted-Set中的位置索引值。0表示第一个位置。 redis 127.0.0.1:6379&gt; zrank myzset one (integer) 0 #成员four并不存在，因此返回nil。 redis 127.0.0.1:6379&gt; zrank myzset four (nil) #获取myzset键中成员的数量。 redis 127.0.0.1:6379&gt; zcard myzset (integer) 3 #返回与myzset关联的Sorted-Set中，分数满足表达式1 &lt;= score &lt;= 2的成员的数量。 redis 127.0.0.1:6379&gt; zcount myzset 1 2 (integer) 2 #删除成员one和two，返回实际删除成员的数量。 redis 127.0.0.1:6379&gt; zrem myzset one two (integer) 2 #查看是否删除成功。 redis 127.0.0.1:6379&gt; zcard myzset (integer) 1 #获取成员three的分数。返回值是字符串形式。 redis 127.0.0.1:6379&gt; zscore myzset three &quot;3&quot; #由于成员two已经被删除，所以该命令返回nil。 redis 127.0.0.1:6379&gt; zscore myzset two (nil) #将成员one的分数增加2，并返回该成员更新后的分数。 redis 127.0.0.1:6379&gt; zincrby myzset 2 one &quot;3&quot; #将成员one的分数增加-1，并返回该成员更新后的分数。 redis 127.0.0.1:6379&gt; zincrby myzset -1 one &quot;2&quot; #查看在更新了成员的分数后是否正确。 redis 127.0.0.1:6379&gt; zrange myzset 0 -1 WITHSCORES 1) &quot;one&quot; 2) &quot;2&quot; 3) &quot;two&quot; 4) &quot;2&quot; 5) &quot;three&quot; 6) &quot;3&quot; 2. ZRANGEBYSCORE/ZREMRANGEBYRANK/ZREMRANGEBYSCORE1234567891011121314151617181920212223242526272829redis 127.0.0.1:6379&gt; del myzset(integer) 1redis 127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four(integer) 4#获取分数满足表达式1 &lt;= score &lt;= 2的成员。redis 127.0.0.1:6379&gt; zrangebyscore myzset 1 21) &quot;one&quot;2) &quot;two&quot;#获取分数满足表达式1 &lt; score &lt;= 2的成员。redis 127.0.0.1:6379&gt; zrangebyscore myzset (1 21) &quot;two&quot;#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的自己，#2表示从位置索引(0-based)等于2的成员开始，去后面3个成员。redis 127.0.0.1:6379&gt; zrangebyscore myzset -inf +inf limit 2 31) &quot;three&quot;2) &quot;four&quot;#删除分数满足表达式1 &lt;= score &lt;= 2的成员，并返回实际删除的数量。redis 127.0.0.1:6379&gt; zremrangebyscore myzset 1 2(integer) 2#看出一下上面的删除是否成功。redis 127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;three&quot;2) &quot;four&quot;#删除位置索引满足表达式0 &lt;= rank &lt;= 1的成员。redis 127.0.0.1:6379&gt; zremrangebyrank myzset 0 1(integer) 2#查看上一条命令是否删除成功。redis 127.0.0.1:6379&gt; zcard myzset(integer) 0 3.ZREVRANGE/ZREVRANGEBYSCORE/ZREVRANK:1234567891011121314151617181920212223242526272829303132333435#为后面的示例准备测试数据。redis 127.0.0.1:6379&gt; del myzset(integer) 0redis 127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three 4 four(integer) 4#以位置索引从高到低的方式获取并返回此区间内的成员。redis 127.0.0.1:6379&gt; zrevrange myzset 0 -1 WITHSCORES1) &quot;four&quot;2) &quot;4&quot;3) &quot;three&quot;4) &quot;3&quot;5) &quot;two&quot;6) &quot;2&quot;7) &quot;one&quot;8) &quot;1&quot;#由于是从高到低的排序，所以位置等于0的是four，1是three，并以此类推。redis 127.0.0.1:6379&gt; zrevrange myzset 1 31) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;#由于是从高到低的排序，所以one的位置是3。redis 127.0.0.1:6379&gt; zrevrank myzset one(integer) 3#由于是从高到低的排序，所以four的位置是0。redis 127.0.0.1:6379&gt; zrevrank myzset four(integer) 0#获取分数满足表达式3 &gt;= score &gt;= 0的成员，并以相反的顺序输出，即从高到底的顺序。redis 127.0.0.1:6379&gt; zrevrangebyscore myzset 3 01) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;#该命令支持limit选项，其含义等同于zrangebyscore中的该选项，只是在计算位置时按照相反的顺序计算和获取。redis 127.0.0.1:6379&gt; zrevrangebyscore myzset 4 0 limit 1 21) &quot;three&quot;2) &quot;two&quot; 四、应用范围：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1). 可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOPTEN的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). Sorted-Sets类型还可用于构建索引数据。","tags":[{"name":"redis","slug":"redis","permalink":"http://www.rxdonny.com/tags/redis/"}]},{"title":"redis-Key操作","date":"2018-04-12T08:57:24.000Z","path":"2018/04/12/redis--Key操作/","text":"一、概述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在该系列的前几篇博客中，主要讲述的是与Redis数据类型相关的命令，如String、List、Set、Hashes和Sorted-Set。这些命令都具有一个共同点，即所有的操作都是针对与Key关联的Value的。而该篇博客将主要讲述与Key相关的Redis命令。学习这些命令对于学习Redis是非常重要的基础，也是能够充分挖掘Redis潜力的利器。 二、相关命令（O表示时间复杂度）KEYS pattern O(N)时间复杂度中的N表示数据库中Key的数量。获取所有匹配pattern参数的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。 匹配模式的键列表。 DEL key [key …] O(N)时间复杂度中的N表示删除的Key数量。从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。 实际被删除的Key数量。 EXISTS key O(1)判断指定键是否存在。 1表示存在，0表示不存在。 MOVE key db O(1)将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。 移动成功返回1，否则0。 RENAME key newkey O(1)为指定指定的键重新命名，如果参数中的两个Keys的命令相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。 RENAMENX key newkey O(1)如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。 1表示修改成功，否则0。 PERSIST key O(1)如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。 1表示Key的过期时间被移出，0表示该Key不存在或没有过期时间。 EXPIRE key seconds O(1)该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 1表示超时被设置，0则表示Key不存在，或不能被设置。 EXPIREAT key timestamp O(1)该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。 1表示超时被设置，0则表示Key不存在，或不能被设置。 TTL key O(1)获取该键所剩的超时描述。 返回所剩描述，如果该键不存在或没有超时设置，则返回-1。 RANDOMKEY O(1)从当前打开的数据库中随机的返回一个Key。 返回的随机键，如果该数据库是空的则返回nil。 TYPE key O(1)获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。 返回的字符串为string、list、set、hash和zset，如果key不存在返回none。 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC|DESC] [ALPHA] [STORE destination] O(N+M*log(M))这个命令相对来说是比较复杂的，因此我们这里只是给出最基本的用法，有兴趣的网友可以去参考redis的官方文档。 返回排序后的原始列表。 三、命令示例：1. KEYS/RENAME/DEL/EXISTS/MOVE/RENAMENX:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#在Shell命令行下启动Redis客户端工具。 /&gt; redis-cli #清空当前选择的数据库，以便于对后面示例的理解。 redis 127.0.0.1:6379&gt; flushdb OK #添加String类型的模拟数据。 redis 127.0.0.1:6379&gt; set mykey 2 OK redis 127.0.0.1:6379&gt; set mykey2 &quot;hello&quot; OK #添加Set类型的模拟数据。 redis 127.0.0.1:6379&gt; sadd mysetkey 1 2 3 (integer) 3 #添加Hash类型的模拟数据。 redis 127.0.0.1:6379&gt; hset mmtest username &quot;stephen&quot; (integer) 1 #根据参数中的模式，获取当前数据库中符合该模式的所有key，从输出可以看出，该命令在执行时并不区分与Key关联的Value类型。 redis 127.0.0.1:6379&gt; keys my* 1) &quot;mysetkey&quot; 2) &quot;mykey&quot; 3) &quot;mykey2&quot; #删除了两个Keys。 redis 127.0.0.1:6379&gt; del mykey mykey2 (integer) 2 #查看一下刚刚删除的Key是否还存在，从返回结果看，mykey确实已经删除了。 redis 127.0.0.1:6379&gt; exists mykey (integer) 0 #查看一下没有删除的Key，以和上面的命令结果进行比较。 redis 127.0.0.1:6379&gt; exists mysetkey (integer) 1 #将当前数据库中的mysetkey键移入到ID为1的数据库中，从结果可以看出已经移动成功。 redis 127.0.0.1:6379&gt; move mysetkey 1 (integer) 1 #打开ID为1的数据库。 redis 127.0.0.1:6379&gt; select 1 OK #查看一下刚刚移动过来的Key是否存在，从返回结果看已经存在了。 redis 127.0.0.1:6379[1]&gt; exists mysetkey (integer) 1 #在重新打开ID为0的缺省数据库。 redis 127.0.0.1:6379[1]&gt; select 0 OK #查看一下刚刚移走的Key是否已经不存在，从返回结果看已经移走。 redis 127.0.0.1:6379&gt; exists mysetkey (integer) 0 #准备新的测试数据。 redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot; OK #将mykey改名为mykey1 redis 127.0.0.1:6379&gt; rename mykey mykey1 OK #由于mykey已经被重新命名，再次获取将返回nil。 redis 127.0.0.1:6379&gt; get mykey (nil) #通过新的键名获取。 redis 127.0.0.1:6379&gt; get mykey1 &quot;hello&quot; #由于mykey已经不存在了，所以返回错误信息。 redis 127.0.0.1:6379&gt; rename mykey mykey1 (error) ERR no such key #为renamenx准备测试key redis 127.0.0.1:6379&gt; set oldkey &quot;hello&quot; OK redis 127.0.0.1:6379&gt; set newkey &quot;world&quot; OK #由于newkey已经存在，因此该命令未能成功执行。 redis 127.0.0.1:6379&gt; renamenx oldkey newkey (integer) 0 #查看newkey的值，发现它也没有被renamenx覆盖。 redis 127.0.0.1:6379&gt; get newkey &quot;world&quot; 2. PERSIST/EXPIRE/EXPIREAT/TTL:1234567891011121314151617181920212223242526272829303132333435363738#为后面的示例准备的测试数据。redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;OK#将该键的超时设置为100秒。redis 127.0.0.1:6379&gt; expire mykey 100(integer) 1#通过ttl命令查看一下还剩下多少秒。redis 127.0.0.1:6379&gt; ttl mykey(integer) 97#立刻执行persist命令，该存在超时的键变成持久化的键，即将该Key的超时去掉。redis 127.0.0.1:6379&gt; persist mykey(integer) 1#ttl的返回值告诉我们，该键已经没有超时了。redis 127.0.0.1:6379&gt; ttl mykey(integer) -1#为后面的expire命令准备数据。redis 127.0.0.1:6379&gt; del mykey(integer) 1redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;OK#设置该键的超时被100秒。redis 127.0.0.1:6379&gt; expire mykey 100(integer) 1#用ttl命令看一下当前还剩下多少秒，从结果中可以看出还剩下96秒。redis 127.0.0.1:6379&gt; ttl mykey(integer) 96#重新更新该键的超时时间为20秒，从返回值可以看出该命令执行成功。redis 127.0.0.1:6379&gt; expire mykey 20(integer) 1#再用ttl确认一下，从结果中可以看出果然被更新了。redis 127.0.0.1:6379&gt; ttl mykey(integer) 17#立刻更新该键的值，以使其超时无效。redis 127.0.0.1:6379&gt; set mykey &quot;world&quot;OK#从ttl的结果可以看出，在上一条修改该键的命令执行后，该键的超时也无效了。redis 127.0.0.1:6379&gt; ttl mykey(integer) -1 3.TYPE/RANDOMKEY/SORT:123456789101112131415161718192021#由于mm键在数据库中不存在，因此该命令返回none。 redis 127.0.0.1:6379&gt; type mm none #mykey的值是字符串类型，因此返回string。 redis 127.0.0.1:6379&gt; type mykey string #准备一个值是set类型的键。 redis 127.0.0.1:6379&gt; sadd mysetkey 1 2 (integer) 2 #mysetkey的键是set，因此返回字符串set。 redis 127.0.0.1:6379&gt; type mysetkey set #返回数据库中的任意键。 redis 127.0.0.1:6379&gt; randomkey &quot;oldkey&quot; #清空当前打开的数据库。 redis 127.0.0.1:6379&gt; flushdb OK #由于没有数据了，因此返回nil。 redis 127.0.0.1:6379&gt; randomkey (nil)","tags":[{"name":"redis","slug":"redis","permalink":"http://www.rxdonny.com/tags/redis/"}]},{"title":"redis数据类型-Set","date":"2018-04-12T06:29:24.000Z","path":"2018/04/12/redis--Set类型/","text":"一、概述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销 二、相关命令（O表示时间复杂度）1、SADD key member [member …] O(N) 时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。 本次操作实际插入的成员数量。2、SCARD key O(1)获取Set中成员的数量。 返回Set中成员的数量，如果该Key并不存在，返回0。 3、SISMEMBER key member O(1)判断参数中指定成员是否已经存在于与Key相关联的Set集合中。 1表示已经存在，0表示不存在，或该Key本身并不存在。 4、SMEMBERS key O(N)时间复杂度中的N表示Set中已经存在的成员数量。获取与该Key关联的Set中所有的成员。返回Set中所有的成员。 5、SPOP key O(1)随机的移除并返回Set中的某一成员。由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。 返回移除的成员，如果该Key并不存在，则返回nil。 6、SREM key member [member …] O(N)时间复杂度中的N表示被删除的成员数量。从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。从Set中实际移除的成员数量，如果没有则返回0。 7、SRANDMEMBER key O(1)和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。 返回随机位置的成员，如果Key不存在则返回nil。 8、SMOVE source destination member O(1)原子性的将参数中的成员从source键移入到destination键所关联的Set中。因此在某一时刻，该成员或者出现在source中，或者出现在destination中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。如果和Key关联的Value不是Set，将返回相关的错误信息。 1表示正常移动，0表示source中并不包含参数成员。 9、SDIFF key [key …] O(N)时间复杂度中的N表示所有Sets中成员的总数量。返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。 差异结果成员的集合。 10、SDIFFSTORE destination key [key …] O(N)该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 返回差异成员的数量。 11、SINTER key [key …] O(N*M)时间复杂度中的N表示最小Set中元素的数量，M则表示参数中Sets的数量。该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。 交集结果成员的集合。 12、SINTERSTORE destination key [key …] O(N*M)该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 返回交集成员的数量。 13、SUNION key [key …] O(N)时间复杂度中的N表示所有Sets中成员的总数量。该命令将返回参数中所有Keys关联的Sets中成员的并集。并集结果成员的集合。 14、SUNIONSTORE destination key [key …] O(N)该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 返回并集成员的数量。 三、命令示例：1. SADD/SMEMBERS/SCARD/SISMEMBER:123456789101112131415161718192021222324#在Shell命令行下启动Redis的客户端程序。 /&gt; redis-cli #插入测试数据，由于该键myset之前并不存在，因此参数中的三个成员都被正常插入。 redis 127.0.0.1:6379&gt; sadd myset a b c (integer) 3 #由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员。 redis 127.0.0.1:6379&gt; sadd myset a d e (integer) 2 #判断a是否已经存在，返回值为1表示存在。 redis 127.0.0.1:6379&gt; sismember myset a (integer) 1 #判断f是否已经存在，返回值为0表示不存在。 redis 127.0.0.1:6379&gt; sismember myset f (integer) 0 #通过smembers命令查看插入的结果，从结果可以，输出的顺序和插入顺序无关。 redis 127.0.0.1:6379&gt; smembers myset 1) &quot;c&quot; 2) &quot;d&quot; 3) &quot;a&quot; 4) &quot;b&quot; 5) &quot;e&quot; #获取Set集合中元素的数量。 redis 127.0.0.1:6379&gt; scard myset (integer) 5 2. SPOP/SREM/SRANDMEMBER/SMOVE:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#删除该键，便于后面的测试。redis 127.0.0.1:6379&gt; del myset(integer) 1#为后面的示例准备测试数据。redis 127.0.0.1:6379&gt; sadd myset a b c d(integer) 4#查看Set中成员的位置。redis 127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;4) &quot;b&quot;#从结果可以看出，该命令确实是随机的返回了某一成员。redis 127.0.0.1:6379&gt; srandmember myset&quot;c&quot;#Set中尾部的成员b被移出并返回，事实上b并不是之前插入的第一个或最后一个成员。redis 127.0.0.1:6379&gt; spop myset&quot;b&quot;#查看移出后Set的成员信息。redis 127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot;#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为2。redis 127.0.0.1:6379&gt; srem myset a d f(integer) 2#查看移出后的输出结果。redis 127.0.0.1:6379&gt; smembers myset1) &quot;c&quot;#为后面的smove命令准备数据。redis 127.0.0.1:6379&gt; sadd myset a b(integer) 2redis 127.0.0.1:6379&gt; sadd myset2 c d(integer) 2#将a从myset移到myset2，从结果可以看出移动成功。redis 127.0.0.1:6379&gt; smove myset myset2 a(integer) 1#再次将a从myset移到myset2，由于此时a已经不是myset的成员了，因此移动失败并返回0。redis 127.0.0.1:6379&gt; smove myset myset2 a(integer) 0#分别查看myset和myset2的成员，确认移动是否真的成功。redis 127.0.0.1:6379&gt; smembers myset1) &quot;b&quot;redis 127.0.0.1:6379&gt; smembers myset21) &quot;c&quot;2) &quot;d&quot;3) &quot;a&quot; 3.SDIFF/SDIFFSTORE/SINTER/SINTERSTORE:1234567891011121314151617181920212223242526272829303132333435363738394041424344#为后面的命令准备测试数据。redis 127.0.0.1:6379&gt; sadd myset a b c d(integer) 4redis 127.0.0.1:6379&gt; sadd myset2 c(integer) 1redis 127.0.0.1:6379&gt; sadd myset3 a c e(integer) 3#myset和myset2相比，a、b和d三个成员是两者之间的差异成员。再用这个结果继续和myset3进行差异比较，b和d是myset3不存在的成员。redis 127.0.0.1:6379&gt; sdiff myset myset2 myset31) &quot;d&quot;2) &quot;b&quot;#将3个集合的差异成员存在在diffkey关联的Set中，并返回插入的成员数量。redis 127.0.0.1:6379&gt; sdiffstore diffkey myset myset2 myset3(integer) 2#查看一下sdiffstore的操作结果。redis 127.0.0.1:6379&gt; smembers diffkey1) &quot;d&quot;2) &quot;b&quot;#从之前准备的数据就可以看出，这三个Set的成员交集只有c。redis 127.0.0.1:6379&gt; sinter myset myset2 myset31) &quot;c&quot;#将3个集合中的交集成员存储到与interkey关联的Set中，并返回交集成员的数量。redis 127.0.0.1:6379&gt; sinterstore interkey myset myset2 myset3(integer) 1#查看一下sinterstore的操作结果。redis 127.0.0.1:6379&gt; smembers interkey1) &quot;c&quot;#获取3个集合中的成员的并集。 redis 127.0.0.1:6379&gt; sunion myset myset2 myset31) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;a&quot;#将3个集合中成员的并集存储到unionkey关联的set中，并返回并集成员的数量。redis 127.0.0.1:6379&gt; sunionstore unionkey myset myset2 myset3(integer) 5#查看一下suiionstore的操作结果。redis 127.0.0.1:6379&gt; smembers unionkey1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;a&quot; 四、应用范围：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1).可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2). 充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。","tags":[{"name":"redis","slug":"redis","permalink":"http://www.rxdonny.com/tags/redis/"}]},{"title":"redis数据类型-List","date":"2018-04-12T05:19:24.000Z","path":"2018/04/12/redis--List类型/","text":"一、概述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 二、相关命令（O表示时间复杂度）1、LPUSH key value [value …] O(1)在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 插入后链表中元素的数量。 2、LPUSHX key value O(1)仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。 插入后链表中元素的数量。 3、LRANGE key start stop O(S+N)时间复杂度中的S为start参数表示的偏移量，N表示元素的数量。该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。 返回指定范围内元素的列表。 4、LPOP key O(1)返回并弹出指定Key关联的链表中的第一个元素，即头部元素，。如果该Key不存，返回nil。 链表头部的元素。 5、LLEN key O(1)返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。 链表中元素的数量。 6、LREM key count value O(N)时间复杂度中N表示链表中元素的数量。在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。 返回被删除的元素数量。 7、LSET key index value O(N)时间复杂度中N表示链表中元素的数量。但是设定头部或尾部的元素时，其时间复杂度为O(1)。设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。 8、LINDEX key index O(N)时间复杂度中N表示在找到该元素时需要遍历的元素数量。对于头部或尾部元素，其时间复杂度为O(1)。该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。 返回请求的元素，如果index超出范围，则返回nil。 9、LTRIM key start stop O(N)N表示被删除的元素数量。该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不错报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。 10、LINSERT key BEFORE|AFTER pivot value O(N)时间复杂度中N表示在找到该元素pivot之前需要遍历的元素数量。这样意味着如果pivot位于链表的头部或尾部时，该命令的时间复杂度为O(1)。该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。 成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。 11、RPUSH key value [value …] O(1)在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 插入后链表中元素的数量。 12、RPUSHX key value O(1)仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。 插入后链表中元素的数量。 13、RPOP key O(1)返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。 链表尾部的元素。 14、RPOPLPUSH source destination O(1)原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。 返回弹出和插入的元素。 三、命令示例：1. LPUSH/LPUSHX/LRANGE:1234567891011121314151617181920212223242526272829/&gt; redis-cli #在Shell提示符下启动redis客户端工具。 redis 127.0.0.1:6379&gt; del mykey (integer) 1 #mykey键并不存在，该命令会创建该键及与其关联的List，之后在将参数中的values从左到右依次插入。 redis 127.0.0.1:6379&gt; lpush mykey a b c d (integer) 4 #取从位置0开始到位置2结束的3个元素。 redis 127.0.0.1:6379&gt; lrange mykey 0 2 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; #取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; #mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0。 redis 127.0.0.1:6379&gt; lpushx mykey2 e (integer) 0 #可以看到mykey2没有关联任何List Value。 redis 127.0.0.1:6379&gt; lrange mykey2 0 -1 (empty list or set) #mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量。 redis 127.0.0.1:6379&gt; lpushx mykey e (integer) 5 #获取该键的List Value的头部元素。 redis 127.0.0.1:6379&gt; lrange mykey 0 0 1) &quot;e&quot; 2. LPOP/LLEN:123456789 redis 127.0.0.1:6379&gt; lpush mykey a b c d(integer) 4redis 127.0.0.1:6379&gt; lpop mykey&quot;d&quot;redis 127.0.0.1:6379&gt; lpop mykey&quot;c&quot;#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2redis 127.0.0.1:6379&gt; llen mykey(integer) 2 3. LREM/LSET/LINDEX/LTRIM:1234567891011121314151617181920212223242526272829303132333435363738 #为后面的示例准备测试数据。 redis 127.0.0.1:6379&gt; lpush mykey a b c d a c (integer) 6 #从头部(left)向尾部(right)变量链表，删除2个值等于a的元素，返回值为实际删除的数量。 redis 127.0.0.1:6379&gt; lrem mykey 2 a (integer) 2 #看出删除后链表中的全部元素。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;c&quot; 2) &quot;d&quot; 3) &quot;c&quot; 4) &quot;b&quot; #获取索引值为1(头部的第二个元素)的元素值。 redis 127.0.0.1:6379&gt; lindex mykey 1 &quot;d&quot; #将索引值为1(头部的第二个元素)的元素值设置为新值e。 redis 127.0.0.1:6379&gt; lset mykey 1 e OK #查看是否设置成功。 redis 127.0.0.1:6379&gt; lindex mykey 1 &quot;e&quot; #索引值6超过了链表中元素的数量，该命令返回nil。 redis 127.0.0.1:6379&gt; lindex mykey 6 (nil) #设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。 redis 127.0.0.1:6379&gt; lset mykey 6 hh (error) ERR index out of range #仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。 redis 127.0.0.1:6379&gt; ltrim mykey 0 2 OK #查看trim后的结果。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;c&quot; 2) &quot;e&quot; 3) &quot;c&quot;``` ##### 4. LINSERT: #删除该键便于后面的测试。 redis 127.0.0.1:6379&gt; del mykey (integer) 1 #为后面的示例准备测试数据。 redis 127.0.0.1:6379&gt; lpush mykey a b c d e (integer) 5 #在a的前面插入新元素a1。 redis 127.0.0.1:6379&gt; linsert mykey before a a1 (integer) 6 #查看是否插入成功，从结果看已经插入。注意lindex的index值是0-based。 redis 127.0.0.1:6379&gt; lindex mykey 0 &quot;e&quot; #在e的后面插入新元素e2，从返回结果看已经插入成功。 redis 127.0.0.1:6379&gt; linsert mykey after e e2 (integer) 7 #再次查看是否插入成功。 redis 127.0.0.1:6379&gt; lindex mykey 1 &quot;e2&quot; #在不存在的元素之前或之后插入新元素，该命令操作失败，并返回-1。 redis 127.0.0.1:6379&gt; linsert mykey after k a (integer) -1 #为不存在的Key插入新元素，该命令操作失败，返回0。 redis 127.0.0.1:6379&gt; linsert mykey1 after a a2 (integer) 0 1##### 5. RPUSH/RPUSHX/RPOP/RPOPLPUSH: #删除该键，以便于后面的测试。 redis 127.0.0.1:6379&gt; del mykey (integer) 1 #从链表的尾部插入参数中给出的values，插入顺序是从左到右依次插入。 redis 127.0.0.1:6379&gt; rpush mykey a b c d (integer) 4 #通过lrange的可以获悉rpush在插入多值时的插入顺序。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;d&quot; #该键已经存在并且包含4个元素，rpushx命令将执行成功，并将元素e插入到链表的尾部。 redis 127.0.0.1:6379&gt; rpushx mykey e (integer) 5 #通过lindex命令可以看出之前的rpushx命令确实执行成功，因为索引值为4的元素已经是新元素了。 redis 127.0.0.1:6379&gt; lindex mykey 4 &quot;e&quot; #由于mykey2键并不存在，因此该命令不会插入数据，其返回值为0。 redis 127.0.0.1:6379&gt; rpushx mykey2 e (integer) 0 #在执行rpoplpush命令前，先看一下mykey中链表的元素有哪些，注意他们的位置关系。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;d&quot; 5) &quot;e&quot; #将mykey的尾部元素e弹出，同时再插入到mykey2的头部(原子性的完成这两步操作)。 redis 127.0.0.1:6379&gt; rpoplpush mykey mykey2 &quot;e&quot; #通过lrange命令查看mykey在弹出尾部元素后的结果。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;d&quot; #通过lrange命令查看mykey2在插入元素后的结果。 redis 127.0.0.1:6379&gt; lrange mykey2 0 -1 1) &quot;e&quot; #将source和destination设为同一键，将mykey中的尾部元素移到其头部。 redis 127.0.0.1:6379&gt; rpoplpush mykey mykey &quot;d&quot; #查看移动结果。 redis 127.0.0.1:6379&gt; lrange mykey 0 -1 1) &quot;d&quot; 2) &quot;a&quot; 3) &quot;b&quot; 4) &quot;c&quot; ``` 四、链表结构的小技巧：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对链表结构的Value，Redis在其官方文档中给出了一些实用技巧，如RPOPLPUSH命令，下面给出具体的解释。Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。","tags":[{"name":"redis","slug":"redis","permalink":"http://www.rxdonny.com/tags/redis/"}]},{"title":"redis数据类型-String","date":"2018-04-12T03:11:24.000Z","path":"2018/04/12/redis--String类型/","text":"一、概述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。 二、相关命令（O表示时间复杂度）1、APPEND key value O(1)如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。 追加后Value的长度。 2、DECR key O(1)将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 递减后的Value值。 3、INCR key O(1)将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 递增后的Value值。 4、DECRBY key decrement O(1)将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 减少后的Value值。 5、INCRBY key increment O(1)将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 增加后的Value值。 6、GET key O(1)获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。 与该Key相关的Value，如果该Key不存在，返回nil。 SET key value O(1)设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。 总是返回”OK”。 7、GETSET key value O(1)原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。 返回该Key的原有值，如果该Key之前并不存在，则返回nil。 STRLEN key O(1)返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。 返回指定Key的Value字符长度，如果该Key不存在，返回0。 8、SETEX key seconds value O(1)原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。 9、SETNX key value O(1)如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。 1表示设置成功，否则0。 10、SETRANGE key offset value O(1)替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset -strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。 修改后的字符串Value长度。 11、GETRANGE key start end O(1)如果截取的字符串长度很短，我们可以该命令的时间复杂度视为O(1)，否则就是O(N)，这里N表示截取的子字符串长度。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。 子字符串 12、SETBIT key offset value O(1)设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。 在指定Offset上的BIT原有值。 13、GETBIT key offset O(1)返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。 在指定Offset上的BIT值。 14、MGET key [key …] O(N)N表示获取Key的数量。返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。 返回一组指定Keys的Values的列表。 15、MSET key value [key value …] O(N)N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。 该命令不会失败，始终返回OK。 16、MSETNX key value [key value …] O(N)N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。 1表示所有Keys都设置成功，0则表示没有任何Key被修改。 三、命令示例：1. SET/GET/APPEND/STRLEN:123456789101112131415/&gt; redis-cli #执行Redis客户端工具。redis 127.0.0.1:6379&gt; exists mykey #判断该键是否存在，存在返回1，否则返回0。(integer) 0redis 127.0.0.1:6379&gt; append mykey &quot;hello&quot; #该键并不存在，因此append命令返回当前Value的长度。(integer) 5redis 127.0.0.1:6379&gt; append mykey &quot; world&quot; #该键已经存在，因此返回追加后Value的长度。(integer) 11redis 127.0.0.1:6379&gt; get mykey #通过get命令获取该键，以判断append的结果。&quot;hello world&quot;redis 127.0.0.1:6379&gt; set mykey &quot;this is a test&quot; #通过set命令为键设置新值，并覆盖原有值。OKredis 127.0.0.1:6379&gt; get mykey&quot;this is a test&quot;redis 127.0.0.1:6379&gt; strlen mykey #获取指定Key的字符长度，等效于C库中strlen函数。(integer) 14 2. INCR/DECR/INCRBY/DECRBY:123456789101112131415161718192021222324redis 127.0.0.1:6379&gt; set mykey 20 #设置Key的值为20OKredis 127.0.0.1:6379&gt; incr mykey #该Key的值递增1(integer) 21redis 127.0.0.1:6379&gt; decr mykey #该Key的值递减1(integer) 20redis 127.0.0.1:6379&gt; del mykey #删除已有键。(integer) 1redis 127.0.0.1:6379&gt; decr mykey #对空值执行递减操作，其原值被设定为0，递减后的值为-1(integer) -1redis 127.0.0.1:6379&gt; del mykey (integer) 1redis 127.0.0.1:6379&gt; incr mykey #对空值执行递增操作，其原值被设定为0，递增后的值为1(integer) 1redis 127.0.0.1:6379&gt; set mykey hello #将该键的Value设置为不能转换为整型的普通字符串。OKredis 127.0.0.1:6379&gt; incr mykey #在该键上再次执行递增操作时，Redis将报告错误信息。(error) ERR value is not an integer or out of rangeredis 127.0.0.1:6379&gt; set mykey 10OKredis 127.0.0.1:6379&gt; decrby mykey 5 (integer) 5redis 127.0.0.1:6379&gt; incrby mykey 10(integer) 15 3. GETSET：12345678910 redis 127.0.0.1:6379&gt; incr mycounter #将计数器的值原子性的递增1 (integer) 1 #在获取计数器原有值的同时，并将其设置为新值，这两个操作原子性的同时完成。 redis 127.0.0.1:6379&gt; getset mycounter 0 &quot;1&quot; redis 127.0.0.1:6379&gt; get mycounter #查看设置后的结果。 &quot;0&quot;``` ##### 4. SETEX: redis 127.0.0.1:6379&gt; setex mykey 10 &quot;hello&quot; #设置指定Key的过期时间为10秒。 OK #通过ttl命令查看一下指定Key的剩余存活时间(秒数)，0表示已经过期，-1表示永不过期。 redis 127.0.0.1:6379&gt; ttl mykey (integer) 4 redis 127.0.0.1:6379&gt; get mykey #在该键的存活期内我们仍然可以获取到它的Value。 &quot;hello&quot; redis 127.0.0.1:6379&gt; ttl mykey #该ttl命令的返回值显示，该Key已经过期。 (integer) 0 redis 127.0.0.1:6379&gt; get mykey #获取已过期的Key将返回nil。 (nil) 1##### 5. SETNX: redis 127.0.0.1:6379&gt; del mykey #删除该键，以便于下面的测试验证。 (integer) 1 redis 127.0.0.1:6379&gt; setnx mykey &quot;hello&quot; #该键并不存在，因此该命令执行成功。 (integer) 1 redis 127.0.0.1:6379&gt; setnx mykey &quot;world&quot; #该键已经存在，因此本次设置没有产生任何效果。 (integer) 0 redis 127.0.0.1:6379&gt; get mykey #从结果可以看出，返回的值仍为第一次设置的值。 &quot;hello&quot; 1##### 6. SETRANGE/GETRANGE: redis 127.0.0.1:6379&gt; set mykey &quot;hello world&quot; #设定初始值。 OK redis 127.0.0.1:6379&gt; setrange mykey 6 dd #从第六个字节开始替换2个字节(dd只有2个字节) (integer) 11 redis 127.0.0.1:6379&gt; get mykey #查看替换后的值。 &quot;hello ddrld&quot; redis 127.0.0.1:6379&gt; setrange mykey 20 dd #offset已经超过该Key原有值的长度了，该命令将会在末尾补0。 (integer) 22 redis 127.0.0.1:6379&gt; get mykey #查看补0后替换的结果。 &quot;hello ddrld\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00dd&quot; redis 127.0.0.1:6379&gt; del mykey #删除该Key。 (integer) 1 redis 127.0.0.1:6379&gt; setrange mykey 2 dd #替换空值。 (integer) 4 redis 127.0.0.1:6379&gt; get mykey #查看替换空值后的结果。 &quot;\\x00\\x00dd&quot; redis 127.0.0.1:6379&gt; set mykey &quot;0123456789&quot; #设置新值。 OK redis 127.0.0.1:6379&gt; getrange mykey 1 2 #截取该键的Value，从第一个字节开始，到第二个字节结束。 &quot;12&quot; redis 127.0.0.1:6379&gt; getrange mykey 1 20 #20已经超过Value的总长度，因此将截取第一个字节后面的所有字节。 &quot;123456789&quot; 1##### 7. SETBIT/GETBIT: redis 127.0.0.1:6379&gt; del mykey (integer) 1 redis 127.0.0.1:6379&gt; setbit mykey 7 1 #设置从0开始计算的第七位BIT值为1，返回原有BIT值0 (integer) 0 redis 127.0.0.1:6379&gt; get mykey #获取设置的结果，二进制的0000 0001的十六进制值为0x01 &quot;\\x01&quot; redis 127.0.0.1:6379&gt; setbit mykey 6 1 #设置从0开始计算的第六位BIT值为1，返回原有BIT值0 (integer) 0 redis 127.0.0.1:6379&gt; get mykey #获取设置的结果，二进制的0000 0011的十六进制值为0x03 &quot;\\x03&quot; redis 127.0.0.1:6379&gt; getbit mykey 6 #返回了指定Offset的BIT值。 (integer) 1 redis 127.0.0.1:6379&gt; getbit mykey 10 #Offset已经超出了value的长度，因此返回0。 (integer) 0 1##### 8. MSET/MGET/MSETNX: redis 127.0.0.1:6379&gt; mset key1 &quot;hello&quot; key2 &quot;world&quot; #批量设置了key1和key2两个键。 OK redis 127.0.0.1:6379&gt; mget key1 key2 #批量获取了key1和key2两个键的值。 1) &quot;hello&quot; 2) &quot;world&quot; #批量设置了key3和key4两个键，因为之前他们并不存在，所以该命令执行成功并返回1。 redis 127.0.0.1:6379&gt; msetnx key3 &quot;stephen&quot; key4 &quot;liu&quot; (integer) 1 redis 127.0.0.1:6379&gt; mget key3 key4 1) &quot;stephen&quot; 2) &quot;liu&quot; #批量设置了key3和key5两个键，但是key3已经存在，所以该命令执行失败并返回0。 redis 127.0.0.1:6379&gt; msetnx key3 &quot;hello&quot; key5 &quot;world&quot; (integer) 0 #批量获取key3和key5，由于key5没有设置成功，所以返回nil。 redis 127.0.0.1:6379&gt; mget key3 key5 1) &quot;stephen&quot; 2) (nil) ```","tags":[{"name":"redis","slug":"redis","permalink":"http://www.rxdonny.com/tags/redis/"}]},{"title":"hibernate的缓存","date":"2018-03-19T06:48:24.000Z","path":"2018/03/19/hibernate的缓存/","text":"什么是缓存：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存就是将数据库/硬盘上文件中的数据放入到缓存中（就是内存中的一块空间），当再次使用的时候，可以直接从内存中获取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存的好处：提升程序运行的效率，缓存技术是hibernate的一个优化手段。 Hibernate缓存的分类1.一级缓存：自带的缓存（是session级别的缓存 每一个session都有一个自己的一级缓存），不可以卸载2.二级缓存：二级缓存是由第三方提供 ehcache oscache（二级缓存是sessionfactory级别的 一个工程只有一个session工厂） （1）拷二级缓存开发包 （2）总的配置文件开启二级缓存 cache.use_second_level_cache （3）配置二级缓存的提供者 cache.provider_class （4）标记使用二级缓存的类 在相应类的配置文件里加3.查询缓存 只给hql语句使用 hibernate query language 和sql 相似 （1）配置二级缓存 （2）总的配置文件开启查询缓存 在总的配置文件中 cache.use_query_cache （3）代码中开启查询缓存 理解Session缓存（一级缓存）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存. 只要 Session 实例没有结束生命周期, 存放在它缓存中的对象也不会结束生命周期 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当session的save()方法持久化一个对象时，该对象被载入缓存，以后即使程序中不再引用该对象，只要缓存不清空，该对象仍然处于生命周期中。当试图get()、 load()对象时，会判断缓存中是否存在该对象，有则返回，此时不查询数据库。没有再查询数据库 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session 能够在某些时间点, 按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库, 这一过程被称为刷出缓存(flush) 实现hibernate的一级缓存1、准备工作数据库创建三张表：商品表goods(goodsid,goodsname),用户表 userinfo(username,password),收藏表collection(uname,gid)建立主外键关系gid-goodsid,uname-username新建工程，创建Goods，UserInfo类并配置。 2、编写测试类test1：证明缓存的存在12345678910111213141516package com.test;import org.hibernate.Session;import com.pojo.Goods;import com.util.HibernateSessionFactory;public class Test &#123; public static void main(String[] args) &#123; Session session = HibernateSessionFactory.getSession(); Goods goods = (Goods) session.get(Goods.class, 1); //如果 session没有关闭 下面创建的session2 和session 同时指向一个缓存 即 session 和session2 是同一个 Session session2 = HibernateSessionFactory.getSession(); Goods goods2 = (Goods) session2.get(Goods.class, 1); System.out.println(goods.getGoodsid()+\"\\t\" + goods.getGoodsname()); System.out.println(goods2.getGoodsid()+\"\\t\" + goods2.getGoodsname()); &#125;&#125; 运行结果为：结果中只有一条SQL语句，并且输出的结果是一样的，说明程序在执行Goods goods2 = (Goods) session2.get(Goods.class, 1);时没有发送SQL语句，返回的结果是从缓存中读取的。 3、编写测试类test2：","tags":[{"name":"hibernate","slug":"hibernate","permalink":"http://www.rxdonny.com/tags/hibernate/"}]},{"title":"hibernate多对多关系","date":"2018-03-19T06:48:24.000Z","path":"2018/03/19/hibernate多对多关系/","text":"原理：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多对多关系在数据库中是通过建立中间表来实现的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多对多关系在类中的实现方式：在类中不需要编写中间表对应的类，在类中用两个集合来实现中间表。 准备工作数据库创建三张表：商品表goods(goodsid,goodsname),用户表 userinfo(username,password),收藏表collection(uname,gid)建立主外键关系gid-goodsid,uname-username新建工程，创建Goods，UserInfo类并配置。 ###（1）pojo.Goods 类中除了与表goods字段一一对应的变量以外，还定义一个pojo.UserInfo 的对象集合 1234567891011121314151617181920212223242526272829 package com.pojo;import java.util.HashSet;import java.util.Set;public class Goods &#123; private int goodsid; private String goodsname; // 通过集合来实现中间表 private Set&lt;UserInfo&gt; infos = new HashSet&lt;UserInfo&gt;(0); public Set&lt;UserInfo&gt; getInfos() &#123; return infos; &#125; public void setInfos(Set&lt;UserInfo&gt; infos) &#123; this.infos = infos; &#125; public int getGoodsid() &#123; return goodsid; &#125; public void setGoodsid(int goodsid) &#123; this.goodsid = goodsid; &#125; public String getGoodsname() &#123; return goodsname; &#125; public void setGoodsname(String goodsname) &#123; this.goodsname = goodsname; &#125;&#125; （2） 在pojo.Goods的配置文件Goods.hbm.xml进行如下配置 1234567891011121314151617181920 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- pojo的映射文件 orm --&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.pojo.Goods\" table=\"goods\"&gt; &lt;id name=\"goodsid\" column=\"goodsid\"&gt; &lt;generator class=\"assigned\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"goodsname\" column=\"goodsname\"&gt;&lt;/property&gt; &lt;!-- 指定中间表 inverse=\"true\" 表示反转 不负责维护关系 默认false --&gt; &lt;set name=\"infos\" table=\"collection\" inverse=\"true\"&gt; &lt;key column=\"gid\"&gt;&lt;/key&gt; &lt;many-to-many class=\"com.pojo.UserInfo\" column=\"uname\"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; ###（3）pojo.UserInfo 类中除了与表userinfo字段一一对应的变量以外，还定义一个pojo.Goods 的对象集合 1234567891011121314151617181920212223242526272829303132 package com.pojo;import java.util.HashSet;import java.util.Set;public class UserInfo &#123; private String username; private String password; private Set&lt;Goods&gt; goods = new HashSet&lt;Goods&gt;(0); public Set&lt;Goods&gt; getGoods() &#123; return goods; &#125; public void setGoods(Set&lt;Goods&gt; goods) &#123; this.goods = goods; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; （2） 在pojo.UserInfo的配置文件UserInfo.hbm.xml进行如下配置 12345678910111213141516171819 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- pojo的映射文件 orm --&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.pojo.UserInfo\" table=\"userinfo\"&gt; &lt;id name=\"username\" column=\"username\"&gt; &lt;generator class=\"assigned\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"password\" column=\"password\"&gt;&lt;/property&gt; &lt;!--指定 中间表 --&gt; &lt;set name=\"goods\" table=\"collection\" cascade=\"all\"&gt; &lt;key column=\"uname\"&gt;&lt;/key&gt; &lt;many-to-many class=\"com.pojo.Goods\" column=\"gid\"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试：创建Test测试类（1）在收藏夹中添加一条记录思想：1）新增一个用户2）添加一件商品3）session.save()后程序自动在collection中添加一条记录 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.pojo.Goods;import com.pojo.UserInfo;public class Test &#123; public static void main(String[] args) &#123; Configuration configuration = new Configuration().configure(); SessionFactory factory = configuration.buildSessionFactory(); Session session = factory.openSession(); Transaction transaction = session.beginTransaction(); // 新增一个用户 UserInfo info = new UserInfo(); info.setUsername(\"xiao1\"); info.setPassword(\"123456\"); // 添加一件商品 Goods goods = new Goods(); goods.setGoodsid(4); goods.setGoodsname(\"手机4\"); // 操作中间表 //goods.getInfos().add(info); // 若goods的配置文件Goods.hbm.xml &lt;set&gt;&lt;set/&gt;标签中inverse=\"true\" 则不能实现 添加 即不负责维护关系 info.getGoods().add(goods); // 下面两条语句顺序不影响结果 session.save(info); session.save(goods); transaction.commit(); session.close(); &#125;&#125; （2）查询某用户收藏的商品思想：1）现在数据库中找到要查询的用户2）根据用户得到其收藏的商品对象集合3）foreach循环输出 123456789101112131415161718192021222324package com.test;import java.util.Set;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.pojo.Goods;import com.pojo.UserInfo;public class Test1_query &#123; public static void main(String[] args) &#123; Configuration configuration = new Configuration().configure(); SessionFactory factory = configuration.buildSessionFactory(); Session session = factory.openSession(); // 查询某个用户收藏的商品 // 先找到想要查询的用户 UserInfo info = (UserInfo) session.get(UserInfo.class, \"xiaohei\"); Set&lt;Goods&gt; goods = info.getGoods(); for (Goods goods2 : goods) &#123; System.out.println(goods2.getGoodsid()+\"\\t\"+goods2.getGoodsname()); &#125; session.close(); &#125;&#125; （3）清除某用户收藏的一个或商品原理：操作中间表其实就是操作集合思想：1）现在数据库中找到要查询的用户info2）根据用户得到其收藏的商品对象集合3）清空：集合.clear();4）清除某一个：找到具体要清除的商品goods，然后 info.getGoods().remove(goods); 1234567891011121314151617181920212223242526272829303132333435package com.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.pojo.Goods;import com.pojo.UserInfo;/* * 清除某用户收藏的所有商品 * 原理：在中间表中删除用户x的所有记录 * 操作： 操作中间表实际就是操作集合 * * */public class Test2_del &#123; public static void main(String[] args) &#123; Configuration configuration = new Configuration().configure(); SessionFactory factory = configuration.buildSessionFactory(); Session session = factory.openSession(); Transaction transaction = session.beginTransaction(); UserInfo info = (UserInfo) session.get(UserInfo.class, \"小龙\"); //Goods goods = (Goods) session.get(Goods.class, 1); //info.getGoods().remove(goods); 删除某一个收藏 info.getGoods().clear(); // 清空收藏夹 session.save(info); transaction.commit(); session.close(); &#125;&#125;","tags":[{"name":"hibernate","slug":"hibernate","permalink":"http://www.rxdonny.com/tags/hibernate/"}]},{"title":"hibernate一对多关系","date":"2018-03-19T02:39:24.000Z","path":"2018/03/19/hibernate一对多关系/","text":"原理：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一对多关系在数据库中是通过主外键的形式来实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一对多关系在类中有两种实现方式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）单向关系（效率高）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该关系由“多”的一方来维护；就是在“多”的一方的pojo中添加“一”的一方的对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）双向关系（效率低）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该关系由“一”的一方来维护；就是在“一”的一方的pojo中添加“多”的一方的对象集合 准备工作数据库创建两张表：部门表dep(depid,depname),员工表emp(empid,empname,did),建立主外键关系depid-did,新建工程并配置，创建Dep，Emp类。 1.单向关系——该关系由“多”的一方来维护（emp） （1） 在“多”的一方的pojo中添加“一”的一方的对象，在pojo.Emp类中添加如下变量 12345678910111213141516171819202122232425262728 package com.pojo;public class Emp &#123; private int empid; private String empname; private Dep dep ;// 添加dep的对象 指的是在哪个部门 public Dep getDep() &#123; return dep; &#125; public void setDep(Dep dep) &#123; this.dep = dep; &#125; public int getEmpid() &#123; return empid; &#125; public void setEmpid(int empid) &#123; this.empid = empid; &#125; public String getEmpname() &#123; return empname; &#125; public void setEmpname(String empname) &#123; this.empname = empname; &#125; &#125; （2） 在pojo.Emp的配置文件Emp.hbm.xml进行如下配置 123456789101112131415161718 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 配置的是表和类的关系 --&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.pojo.Emp\" table=\"emp\"&gt; &lt;id name=\"empid\" column=\"empid\"&gt; &lt;generator class=\"assigned\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"empname\" column=\"empname\"&gt;&lt;/property&gt; &lt;!-- 一对多在“多”的一方实现的配置部分 --&gt; &lt;many-to-one name=\"dep\" column=\"did\" class=\"com.pojo.Dep\" cascade=\"all\"&gt;&lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 测试：创建Test测试类12345678910111213141516171819202122package com.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.pojo.Emp;public class Test3 &#123; public static void main(String[] args) &#123; Configuration configuration = new Configuration().configure(); SessionFactory factory = configuration.buildSessionFactory(); Session session = factory.openSession(); Transaction transaction = session.beginTransaction(); //查询某个员工并得到所在的部门 Emp emp = (Emp) session.get(Emp.class, 1); System.out.println(emp.getEmpid() + \"\\t\" + emp.getEmpname() + \"\\t\"+ emp.getDep().getDepname()); transaction.commit(); session.close(); &#125;&#125; 2.单向关系——该关系由“一”的一方来维护（dep） （1） 在“一”的一方的pojo中添加“多”的一方的对象集合，在pojo.Dep类中添加如下变量 123456789101112131415161718192021222324252627282930 package com.pojo;import java.util.HashSet;import java.util.Set;public class Dep &#123; private int depid; private String depname; // 添加emp的对象集合 指在该部门下有哪些员工 private Set&lt;Emp&gt; emps = new HashSet&lt;Emp&gt;(0); public Set&lt;Emp&gt; getEmps() &#123; return emps; &#125; public void setEmps(Set&lt;Emp&gt; emps) &#123; this.emps = emps; &#125; public int getDepid() &#123; return depid; &#125; public void setDepid(int depid) &#123; this.depid = depid; &#125; public String getDepname() &#123; return depname; &#125; public void setDepname(String depname) &#123; this.depname = depname; &#125;&#125; （2） 在pojo.Dep的配置文件Dep.hbm.xml进行如下配置 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 配置的是表和类的关系 --&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.pojo.Dep\" table=\"dep\"&gt; &lt;id name=\"depid\" column=\"depid\"&gt; &lt;generator class=\"assigned\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"depname\" column=\"depname\"&gt;&lt;/property&gt; &lt;!-- 部门有哪些员工 order-by：排序方式 cascade：级联--&gt; &lt;set name=\"emps\" order-by=\"empid asc\" cascade=\"save-update\"&gt; &lt;key column=\"did\"&gt;&lt;/key&gt; &lt;one-to-many class=\"com.pojo.Emp\"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试：创建Test测试类1234567891011121314151617181920212223242526272829303132333435package com.test;import java.util.Set;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.pojo.Dep;import com.pojo.Emp;public class Test3 &#123; public static void main(String[] args) &#123; Configuration configuration = new Configuration().configure(); SessionFactory factory = configuration.buildSessionFactory(); Session session = factory.openSession(); Transaction transaction = session.beginTransaction(); Dep dep = (Dep) session.get(Dep.class, 1); Set&lt;Emp&gt; emps = dep.getEmps(); System.out.println(\"显示该部门的所有员工：\"); for (Emp emp2 : emps) &#123; System.out.println(emp2.getEmpid()+\"\\t\"+emp2.getEmpname()+\"\\t\"+emp2.getDep().getDepname()); &#125; transaction.commit(); session.close(); &#125;&#125; 引申cascade属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在处理一对一、一对多、多对多的关系时，有时会涉及到级联的操作，上面例子中也有体现，即属性cascade：翻译为串联的意思，表示级联操作。级联的意思是：本实体做了什么事，也要拉上另一个关联的实体，导致另一个实体跟着做事情。就是说我删除了，你也得删除！ 关联目标，指的是关联的那个实体。具体的解释可以百度，很详细。 cascade属性的可能值有&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all: 所有情况下均进行关联操作，即save-update和delete。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; none: 所有情况下均不进行关联操作。这是默认值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; save-update: 在执行save/update/saveOrUpdate时进行关联操作。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete: 在执行delete 时进行关联操作。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all-delete-orphan:当一个节点在对象图中成为孤儿节点时，删除该节点。比如在一个一对多的关系中，Student包含多个book，当在对象关系中删除一个book时，此book即成为孤儿节点。 lazy（懒加载）属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 懒加载又称延迟加载，它保证了应用只有在需要时才去数据库中抓取相应的记录。通过延迟加载技术可以避免过多、过早地加载数据表里的数据，从而降低应用的内存开销。Hibernate 的延迟加载本质上就是代理模式的应用，当程序通过 Hibernate 装载一个实体时，默认情况下，Hibernate 并不会立即抓取它的集合属性、关联实体所以对应的记录，而是通过生成一个代理来表示这些集合属性、关联实体，这就是代理模式应用带来的优势。但是，延迟加载也是项目开发中特别常见的一个错误。如果对一个类或者集合配置了延迟检索策略，那么必须当代理类实例或代理集合处于持久化状态（即处于Session范围内）时，才能初始化它。如果在游离状态时才初始化它，就会产生延迟初始化错误。所以，在开发独立的DAO数据访问层时应该格外小心这个问题。 如果在获取对象的时候使用的是session.get()是不会延迟加载的，只有在使用load、hql时候才会延迟加载。 session的两种方法 get/load&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get和load关系的比较&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.get是立即加载，不管要不要用这个对象都立马查询；load是懒加载，需要用的时候加载。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.get找不到对象时会返回null；load找不到对象会报错。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.get返回的是pojo对象；load返回的是代理对象。","tags":[{"name":"hibernate","slug":"hibernate","permalink":"http://www.rxdonny.com/tags/hibernate/"}]},{"title":"手动配置hibernate及简单使用规范","date":"2018-03-19T00:35:24.000Z","path":"2018/03/19/手动配置hibernate及简单使用规范/","text":"记录一下手动配置hibernate的过程及操作准备工作 三拷三配1.三拷；资源在网上都可以找得到 （1） 拷jdbc驱动，放在“工程/WebRoot/WEB-INF/lib”文件夹下 （2） 拷hibernate开发包，放在“工程/WebRoot/WEB-INF/lib”文件夹下 （3） 拷log4j，放在“工程/src”文件夹下 2.三配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如：数据库有表dep（depid，depname） （1） 配置pojo，即配置class，实现class-table一一对应；如：创建Dep类 123456789101112131415161718 package com.pojo;public class Dep &#123; private int depid; private String depname; public int getDepid() &#123; return depid; &#125; public void setDepid(int depid) &#123; this.depid = depid; &#125; public String getDepname() &#123; return depname; &#125; public void setDepname(String depname) &#123; this.depname = depname; &#125;&#125; （2） 配置pojo的配置文件,真正实现class-table的一一对应；如：创建Dep.hbm.xml文件，该文件放在同Dep类一个包内（这里是放在pojo包中）；有如下基本配置：12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 配置的是orm关系 --&gt;&lt;!-- 该xml文件 .hbm.xml 前可以改名 这是最容易配置的文件--&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.pojo.Dep\" table=\"dep\"&gt;&lt;!-- 配置的是表和类的关系 --&gt; &lt;!-- 主键的配置 --&gt; &lt;id column=\"depid\" name=\"depid\"&gt; &lt;generator class=\"assigned\"&gt;&lt;/generator&gt;&lt;!-- 自己设计主键 --&gt; &lt;/id&gt; &lt;!-- 非主键的配置 --&gt; &lt;property name=\"depname\" column=\"depname\" length=\"20\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; （3）配置总的配置文件hibernate.cfg.xml（该文件不可以随意改名）123456789101112131415161718192021222324&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- 配置的jdbc的参数 --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 设置jdbc访问数据库的4个参数 当要切换使用数据库时只需要修改这个部分就可以了 --&gt; &lt;property name=\"connection.username\"&gt;sa&lt;/property&gt;&lt;!-- 你的数据库用户名 --&gt; &lt;property name=\"connection.password\"&gt;sasa&lt;/property&gt;&lt;!-- 你的数据库登录密码 --&gt; &lt;property name=\"connection.driver_class\"&gt;&lt;!-- 驱动：各种数据库的驱动不同 --&gt; com.microsoft.sqlserver.jdbc.SQLServerDriver &lt;/property&gt; &lt;property name=\"connection.url\"&gt;&lt;!-- 要使用的数据库名（s53） --&gt; jdbc:sqlserver://127.0.0.1:1433;DatabaseName=s53 &lt;/property&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt;&lt;!-- 方便起见：必须设置 显示sql --&gt; &lt;!-- 设置方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.SQLServerDialect&lt;/property&gt; &lt;!-- pojo的映射文件，必加，因为在使用过程中，第一步读取配置文件操作只会读取总的配置文件而不会单独读取pojo的配置文件 --&gt; &lt;mapping resource=\"com/pojo/Dep.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试：创建Test测试类123456789101112131415161718192021222324252627package com.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.pojo.Dep;public class Test &#123; public static void main(String[] args) &#123; // 1.读取总的配置文件 Configuration configuration = new Configuration().configure(); // 2.创建session工厂 SessionFactory factory = configuration.buildSessionFactory(); // 3.得到session 就是对connection对象进行了封装 Session session = factory.openSession(); // 4.开启事务 -- 执行查询操作时可以不开事务 Transaction transaction = session.beginTransaction(); Dep dep = new Dep(); dep.setDepid(2); dep.setDepname(\"李四\"); // 5.持久化 session.save(dep);// 保存 // 6.提交事务 transaction.commit(); // 7.关闭session session.close(); &#125;&#125;","tags":[{"name":"hibernate","slug":"hibernate","permalink":"http://www.rxdonny.com/tags/hibernate/"}]},{"title":"Linux-LVS负载均衡之DR方法实现","date":"2018-01-03T13:51:24.000Z","path":"2018/01/03/LVS负载均衡之DR方法实现/","text":"实现原理图： 准备工作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该练习需要三个主机（本人使用的是CentOS6.4版本操作系统），可以通过虚拟机克隆技术克隆另外两个主机，当然，克隆完之后记得更改主机名，便于操作与识别。一台充当LVS服务器（lvs-server:（单网卡：eth0:200.168.10.1））另外两台真实服务器（real-server1（单网卡：200.168.10.2）、real-server2（单网卡：：200.168.10.3）） （1） 添加虚拟网络VMnet1，设置网段：200.168.10.0 ，子网掩码：255.255.255.0；（2） vmnet1 win7下设置IP为：200.168.10.4，netmask：255.255.255.0，不需要指定网关（3） 在Lvsserver安装软件ipvsadm（此步可以提前，需要在NAT网络连接模式开启）：yum -y install ipvsadm*（4）使用vmnet1（模拟外网），除了vmnet1之外，其它网络全部关掉（否则有可能会对实验结果造成影响，记住，是有可能！） 开始配置1、配置IP （均使用vmnet1网段）（1）lvsserver: 配置临时ip(本实验为临时测试)ifconfig eth0 200.168.10.1 netmask 255.255.255.0（2）real-server1 配置临时ip:ifconfig eth0 200.168.10.2（3）real-server2 配置临时ip:ifconfig eth0 200.168.10.3 2、依次检查防火墙（lvs-server, real-server1,real-server2）iptables-L -n (iptables)sestatus(selinux) 3、在lvs-server上开启路由管道echo 1 &gt; /proc/sys/net/ipv4/ip_forward 4、lvs-server配置（1）配置 dr serveripvsadm-Cipvsadm-At 200.168.10.10:80 -s rripvsadm-at 200.168.10.10:80 -r 200.168.10.2:80 -gipvsadm-at 200.168.10.10:80 -r 200.168.10.3:80 -gipvsadm-L –n （2）DR服务器配置虚拟IP并添加路由1) ifconfig lo:0 200.168.10.10 netmask 255.255.255.255 up2) route add -host 200.168.10.10 dev lo:0 5、分别配置两个真实服务器real-server1,real-server2ifconfig lo:0 200.168.10.10 netmask255.255.255.255 uproute add -host 200.168.10.10 dev lo:0route -n （查看:real-server2为例） 两台服务器继续配置： echo 1 &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho 2 &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho 1 &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho 2 &gt;/proc/sys/net/ipv4/conf/all/arp_announce 6、添加HTML用于测试显示（1) 在real-server1设置service httpd restartcd /var/www/html/echo “&lt;h1&gt; &lt;font color=’red’&gt;lvs之dr：200.168.10.2 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html（2)在real-server2设置service httpd restartcd /var/www/html/echo “&lt;h1&gt; &lt;font color=’blue’&gt;lvs之dr：200.168.10.3 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html 测试打开Windows浏览器，在地址栏输入200.168.10.10,回车，显示内容为下图或者 当点击刷新按钮时会显示另外一个网页。 完毕！谢谢浏览！","tags":[{"name":"Linux-LVS","slug":"Linux-LVS","permalink":"http://www.rxdonny.com/tags/Linux-LVS/"},{"name":"VS/DR","slug":"VS-DR","permalink":"http://www.rxdonny.com/tags/VS-DR/"}]},{"title":"Linux-LVS负载均衡之TUN（隧道技术）方法实现","date":"2018-01-03T13:19:33.000Z","path":"2018/01/03/LVS负载均衡之TUN方法实现/","text":"实现原理图： 准备工作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该练习需要三个主机（本人使用的是CentOS6.4版本操作系统），可以通过虚拟机克隆技术克隆另外两个主机，当然，克隆完之后记得更改主机名，便于操作与识别。一台充当LVS服务器（lvs-server:（单网卡：eth0:200.168.10.1））另外两台真实服务器（real-server1（单网卡：200.168.10.2）、real-server2（单网卡：：200.168.10.3）） （1） 添加虚拟网络VMnet1，设置网段：200.168.10.0 ，子网掩码：255.255.255.0；（2） vmnet1 win7下设置IP为：200.168.10.4，netmask：255.255.255.0，不需要指定网关（3） 在Lvsserver安装软件ipvsadm（此步可以提前，需要在NAT网络连接模式开启）：yum -y install ipvsadm*（4）使用vmnet1（模拟外网），除了vmnet1之外，其它网络全部关掉（否则有可能会对实验结果造成影响，记住，是有可能！） 开始配置1、配置IP （均使用vmnet1网段）（1）lvsserver: 配置临时ip(本实验为临时测试)ifconfig eth0 200.168.10.1 netmask 255.255.255.0（2）real-server1 配置临时ip:ifconfig eth0 200.168.10.2（3）real-server2 配置临时ip:ifconfig eth0 200.168.10.3 2、依次检查防火墙（lvs-server, real-server1,real-server2）iptables-L -n (iptables)sestatus(selinux) 3、在lvs-server上开启路由管道echo 1 &gt; /proc/sys/net/ipv4/ip_forward 4、lvs-server配置（1）配置 ipmServeripvsadm -Cipvsadm -A -t 200.168.10.10:80 -s rripvsadm -at 200.168.10.10:80 -r 200.168.10.2:80 -iipvsadm -at 200.168.10.10:80 -r 200.168.10.3:80 -iipvsadm -L –n （2）配置虚拟IP1） ifconfig tunl0 200.168.10.10 netmask 255.255.255.255 up //虚拟一个隧道IP 4个255代表它自己一个网段2） route add -host 200.168.10.10 dev tunl0 //把网段 添加到路由表 防止走 200.168.10.0 网段route -n查看 5、分别配置两个真实服务器real-server1,real-server2ifconfig tunl0 200.168.10.10 netmask 255.255.255.255 uproute add –host 200.168.10.10 dev tunl0echo “1” &gt; /proc/sys/net/ipv4/conf/tunl0/arp_ignoreecho “2” &gt; /proc/sys/net/ipv4/conf/tunl0/arp_announceecho “1” &gt; /proc/sys/net/ipv4/conf/all/arp_ignoreecho “2” &gt; /proc/sys/net/ipv4/conf/all/arp_announce PS：如果ping 200.168.10.10能通，但是网页浏览不通。解决方法：分别在真实机运行下面命令echo “0” &gt; /proc/sys/net/ipv4/conf/tunl0/rp_filter 6、添加HTML用于测试显示（1) 在real-server1设置service httpd restartcd /var/www/html/echo “&lt;h1&gt; &lt;font color=’red’&gt;200.168.10.2 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html（2)在real-server2设置service httpd restartcd /var/www/html/echo “&lt;h1&gt; &lt;font color=’blue’&gt;200.168.10.3 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html 测试打开Windows浏览器，在地址栏输入200.168.10.10,回车，显示内容为下图或者 当点击刷新按钮时会显示另外一个网页。 完毕！谢谢浏览！","tags":[{"name":"Linux-LVS","slug":"Linux-LVS","permalink":"http://www.rxdonny.com/tags/Linux-LVS/"},{"name":"VS/TUN","slug":"VS-TUN","permalink":"http://www.rxdonny.com/tags/VS-TUN/"}]},{"title":"Linux-LVS负载均衡之NAT方法实现","date":"2018-01-03T12:22:23.000Z","path":"2018/01/03/LVS负载均衡之NAT方法实现/","text":"实现原理图： 准备工作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该练习需要三个主机（本人使用的是CentOS6.4版本操作系统），可以通过虚拟机克隆技术克隆另外两个主机，当然，克隆完之后记得更改主机名，便于操作与识别。一台充当LVS服务器（lvs-server:（双网卡：eth0:8.8.8.8 eth1:192.168.10.1））另外两台真实服务器（real-server1（单网卡：192.168.10.2）、real-server2（单网卡：：192.168.10.3）） （1） 添加虚拟网络VMnet1，设置网段：8.8.8.0 ，子网掩码：255.255.255.0；添加虚拟网络VMnet2，设置网段：192.168.10.0，子网掩码：255.255.255.0（2） vmnet1 win7下设置IP为：8.8.8.1，netmask：255.255.255.0，不需要指定网关（3） 在Lvsserver安装软件ipvsadm（此步可以提前，需要在NAT网络连接模式开启）：yum -y install ipvsadm*（4）使用vmnet1（模拟外网），vmnet2（模拟内网），除了vmnet1之外，其它网络全部关掉（否则有可能会对实验结果造成影响，记住，是有可能！）（5） lvs-server 配置两块网卡： 开始配置1、配置IP（1）lvsserver: 配置临时ip(本实验为临时测试)ifconfig eth0 8.8.8.8 netmask255.255.255.0ifconfig eth1 192.168.10.1 netmask255.255.255.0（2）real-server1 配置临时ip:ifconfig eth0 192.168.10.2（3）real-server2 配置临时ip:ifconfig eth0 192.168.10.3 2、依次检查防火墙（lvs-server, real-server1,real-server2）iptables-L -n (iptables)sestatus(selinux) 3、real-server1,real-server2分别指定默认网关route add default gw 192.168.10.1route -n (查看) 4、在lvs-server上开启路由管道echo 1 &gt; /proc/sys/net/ipv4/ip_forward 5、添加HTML用于测试显示（1) 在real-server1设置service httpd restartcd /var/www/html/echo “&lt;h1&gt; &lt;font color=’red’&gt;192.168.10.2 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html（2)在real-server2设置service httpd restartcd /var/www/html/echo “&lt;h1&gt; &lt;font color=’blue’&gt;192.168.10.3 &lt;/font&gt; &lt;/h1&gt;” &gt; index.html 6、配置 ipmServer，即在lvs-server上进行配置ipvsadm-Cipvsadm-At 8.8.8.8:80 -s rripvsadm-at 8.8.8.8:80 -r 192.168.10.2:80 -mipvsadm-at 8.8.8.8:80 -r 192.168.10.3:80 -mipvsadm-L –n （查看） 测试打开Windows浏览器，在地址栏输入8.8.8.8,回车，显示内容为下图或者 当点击刷新按钮时会显示另外一个网页。 完毕！谢谢浏览！","tags":[{"name":"Linux-LVS","slug":"Linux-LVS","permalink":"http://www.rxdonny.com/tags/Linux-LVS/"},{"name":"VS/NAT","slug":"VS-NAT","permalink":"http://www.rxdonny.com/tags/VS-NAT/"}]},{"title":"Linux之LVS负载均衡","date":"2018-01-03T11:02:23.000Z","path":"2018/01/03/LVS负载均衡/","text":"LVS (Linux Virtual Server)到底是什么?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一种集群(Cluster)技术，采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。 LVS组成部分 负载调度器（load balancer/ Director），它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址（我们可称之为虚拟IP地址）上的。 服务器池（server pool/Realserver），是一组真正执行客户请求的服务器，执行的服务一般有WEB、MAIL、FTP和DNS等。 共享存储（sharedstorage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。 三种IP负载技术1. VS/NAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VS/NAT(Virtual Server via Network Address Translation)是一种最简单的方式，所有的RealServer只需要将自己的网关指向Director即可。客户端可以是任意操作系统，但此方式下，一个Director能够带动的RealServer比较有限。在VS/NAT的方式下，Director也可以兼为一台RealServer。通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。 2. VS/TUN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，当客户请求越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报 文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。由于一般网络服务应答比请求报文大许多，采用 VS/TUN技术后，集群系统的最大吞吐量可以提高10倍。VS/TUN(Virtual Server via IP Tunneling)隧道（IPtunneling）是将一个IP报文封装在另一个IP报文的技术，这可以使得目标为一个IP地址的数据报文能被封装和转发到另一个IP地址。IP隧道技术亦称为IP封装技术（IP encapsulation）。IP隧道主要用于移动主机和虚拟私有网络（Virtual Private Network），在其中隧道都是静态建立的，隧道一端有一个IP地址，另一端也有唯一的IP地址。它的连接调度和管理与VS/NAT中的一样，只是它的报文转发方法不同。调度器根据各个服务器的负载情况，动态地选择一台服务器，将请求报文封装在另一个IP报文中，再将封装后的IP报文转发给选出的服务器；服务器收到报文后，先将报文解封获得原来目标地址为VIP 的报文，服务器发现VIP地址被配置在本地的IP隧道设备上，所以就处理这个请求，然后根据路由表将响应报文直接返回给客户。 3. VS/DR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VS/DR(Virtual Server via Direct Routing)通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返回给客户。同VS/TUN技术一样，VS/DR技术可极大地 提高集群系统的伸缩性。这种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但是要求调度器与真实服务器都有一块网卡连 在同一物理网段上。 三种方法的优缺点比较 具体配置，请看下一篇！","tags":[{"name":"Linux-LVS","slug":"Linux-LVS","permalink":"http://www.rxdonny.com/tags/Linux-LVS/"}]},{"title":"面向对象有哪些特征","date":"2017-12-31T10:02:23.000Z","path":"2017/12/31/面向对象有哪些特征/","text":"面向对象的主要特征包括抽象、继承、封装和多态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"面向对象技术","slug":"面向对象技术","permalink":"http://www.rxdonny.com/tags/面向对象技术/"}]},{"title":"面向对象与面向过程有什么区别","date":"2017-12-31T08:35:13.000Z","path":"2017/12/31/面向对象与面向过程有什么区别/","text":"什么是面向对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向对象中的对象不是指女朋友，而是一种编程属于。面向对象是当今软件开发方法的主流方法之一，它是把数据及对数据的操作方法放在一起，作为一个相互依存的整体，即对象。对同类对象抽象出其共性，即类，类中的大多数数据，只能被本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。 什么是面向过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向过程是一种以事件为中心的开发方法，就是自顶向下顺序执行，逐步求精，其程序结构是按功能划分为若干个基本模块，这些模块形成一个树状结构，各模块之间的关系也比较简单，在功能上相对独立，每一模块内部一般都是由顺序、选择和循环 3 种基本结构组成，其模块化实现的具体方法是使用子程序，而程序流程在写程序时就已经决定。 不同之处&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体而言，面向对象与面向过程主要有以下几个方面的不同：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) 出发点不同。面向对象方法是用符合常规思维的方式来处理客观世界的问题，强调把问题域的要领直接映射到对象及对象之间的接口上。而面向过程方法强调的则是过程的抽象化与模块化，它是以过程为中心构造或处理客观世界问题的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 层次逻辑关系不同。面向对象方法则是用计算机逻辑来模拟客观世界中的物理存在，以对象的集合类作为处理问题的基本单位，尽可能地使计算机世界向客观世界靠拢，以使问题的处理更清晰直接，面向对象方法是用类的层次结构来体现类之间的继承和发展。而面向过程方法处理问题的基本单位是能清晰准确地表达过程的模块，用模块的层次结构概括模块或模块间的关系与功能，把客观世界的问题抽象成计算机可以处理的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) 数据处理方式与控制程序方式不同。面向对象方法将数据与对应的代码封装成一个整体，原则上其他对象不能直接修改其数据，即对象的修改只能由自身的成员函数完成，控制程序方式上是通过“事件驱动”来激活和运行程序。而面向过程方法是直接通过程序来处理数据，处理完毕后即可显示处理结果，在控制程序方式上是按照设计调用或返回程序，不能自由导航，各模块之间存在着控制与被控制、调用与被调用的关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4) 分析设计与编码转换方式不同。面向对象方法贯穿于软件生命周期的分析、设计及编码中，是一种平滑过程，从分析到设计再到编码是采用一致性的模型表示，即实现的是一种无缝连接。而面向过程方法强调分析、设计及编码之间按规则进行转换，贯穿于软件生命周期的分析、设计及编码中，实现的是一种有缝的连接。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"面向对象技术","slug":"面向对象技术","permalink":"http://www.rxdonny.com/tags/面向对象技术/"}]},{"title":"如何实现类似于C语言中函数指针的功能","date":"2017-12-31T04:26:13.000Z","path":"2017/12/31/如何实现类似于C语言中函数指针的功能/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在C语言中，有一个非常重要的概念——函数指针，其最重要的功能是实现回调函数。所谓回调函数，就是指函数先在某处注册，而它将在稍后某个需要的时候被调用。在Windows系统中，开发人员想让系统动态链接( Dynamic Link Library, DDL )调用自己编写的一个方法，于是利用DDL当中的回调函数的借口来编写程序，通过传递一个函数的指针来被调用，这个过程就称为回调。回调函数一般用于接获消息、获取系统信息或处理异步事件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数指针一般作为函数的参数来使用，开发人员在使用时可以根据自己的需求来传递自定义的函数来实现指定的功能。 例如，在实现排序算法时，可以通过传递一个函数指针来决定两个数的先后顺序，从而最终决定该算法是按升序排序还是降序排序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 java 语言中没有指针的概念，那么如何才能在 java 语言中实现类似于函数指针的功能呢？可以利用接口与类来实现同样的效果。具体而言，先定义一个接口，然后在接口中声明调用的方法，接着实现这个接口，最后把这个实现类的一个对象作为参数传递给调用程序，调用程序通过这个参数来调用指定的函数，从而实现毁掉函数的功能。示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 // 接口中定义了一个用来比较大小的方法 interface IntCompare &#123; public int cmp(int a, int b);&#125;class Cmp1 implements IntCompare &#123; // 升序排序 public int cmp(int a, int b) &#123; if(a &gt; b) return 1; else if(a &lt; b) return -1; else return 0; &#125;&#125;class Cmp2 implements IntCompare &#123; // 降序排序 public int cmp(int a, int b) &#123; if(a &gt; b) return -1; else if(a &lt; b) return 1; else return 0; &#125;&#125;public class FuncPointer &#123; public static void insertSort (int[] a, IntCompare cmp) &#123; if(a != null) &#123; for(int i = 1; i&lt; a.length; i++) &#123; int temp = a[i], j = i; if(cmp.cmp(a[j-1], temp) == 1) &#123; while(j&gt;=1 &amp;&amp; cmp.cmp(a[j-1], temp) == 1) &#123; a[j] = a[j-1]; j--; &#125; &#125; a[j] = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr1 = &#123;7, 3, 19, 40, 4, 7, 1&#125;; insertSort(arr1, new Cmp1()); System.out.print(\"升序排序：\"); for(int i = 0; i &lt; arr1.length; i++) &#123; System.out.print(arr1[i] + \" \"); &#125; System.out.println(); int[] arr2 = &#123;7, 3, 19, 40, 4, 7, 1&#125;; insertSort(arr2, new Cmp2()); System.out.print(\"降序排序：\"); for(int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i] + \" \"); &#125; System.out.println(); &#125;&#125; 运行结果：升序排序：1 3 4 7 7 19 40降序排序：40 19 7 7 4 3 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例定义了一个比较大小的接口 IntCompare, 这个接口实际上充当了C语言中函数指针的功能，在使用时，开发人员可以根据实际需求传入自定义的类。在上例中分别有两个类 Cmp1 和 Cmp2 都实现了这个接口，分别用来在实现升序排序和降序排序时使用。其实这也是策略设计模式所用到的思想","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"package 有什么作用","date":"2017-12-31T04:19:13.000Z","path":"2017/12/31/package 有什么作用/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;package主要是由一组类（class）和接口interface组成。具体而言，package主要有以下两个作用：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）提供多层的命名空间，解决命名冲突；（处于不同package中的类可以拥有相同的名字）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）对类按功能进行分类，使得项目的组织更加清楚。当开发一个类非常多的项目的时候，如果不使用package对类进行分类，而是把所有的类都放在一个package下，代码的可读性比较差，维护性也比较差，会严重影响开发效率。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"},{"name":"package","slug":"package","permalink":"http://www.rxdonny.com/tags/package/"}]},{"title":"什么是反射机制","date":"2017-12-31T03:55:13.000Z","path":"2017/12/31/什么是发射机制/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射机制是Java中一个非常重要的特性，它允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。由于反射机制能够实现在运行时对类进行封装，因此能够增加程序的灵活性，但是不恰当地使用反射机制，也会严重影响系统的性能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体而言，反射机制提供的功能主要有：得到一个对象所属的类；获取一个类的所有成员变量和方法；在运行时创建对象；在运行时调用对象的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，反射机制非常重要的一个作用就是可以在运行时动态地创建类的对象（如JDBC的代码复用），实例如下：12345678910111213141516171819202122232425class Base&#123; public void f() &#123; System.out.println(\"Base\"); &#125;&#125;class Sub extends Base&#123; public void f() &#123; System.out.println(\"Sub\"); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; try&#123; Class c = Class.forName(\"Sub\"); Base b = (Base)c.newInstance(); b.f(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序运行结果为：Sub &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在反射机制中，Class是一个非常重要的类，那么如何才能获取Class类呢？总共有一下3种方法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）Class.forName(“类的路径”)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）类名.Class。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）实例.getClass()。常见面试题：Java创建对象的方式有哪四种？答：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）通过new 语句实例化一个对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）通过反射机制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）通过clone（）方法创建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（4）通过反序列化的方式创建对象","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"},{"name":"反射机制","slug":"反射机制","permalink":"http://www.rxdonny.com/tags/反射机制/"}]},{"title":"为什么Java中有些接口没有任何方法","date":"2017-12-31T02:12:13.000Z","path":"2017/12/31/为什么Java中有些接口没有任何方法/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Java不支持多重继承，即一个类只有一个父类，为了克服单继承的缺点，Java引入了接口这一概念。接口是抽象方法定义的集合（也可以定义一些常量值），是特殊的抽象类。接口中只包含方法的定义，没有方法的实现。接口中的所有方法都是抽象的。接口中成员的作用域修饰符都是public，接口中常量值默认使用public static final 修饰。一个类可以实现多个接口，即实现了多重继承。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从书上看到上面那段话，我依然不清楚，接口到底是什么，用来干什么。为此上了知乎总结了一下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与类相比较，类描述了一个实体，包括实体的状态，也包括实体可能发出的动作，并且描述了这个动作具体的实现步骤。而接口则只定义了一个实体可能发出的动作，没有具体的实现步骤，也没有任何状态信息。因此，接口就有点像一个规范、一个协议，是一个抽象的概念，而类实现了这个协议，满足了这个规范的具体实体，是一个具体的概念。当一组方法需要在很多类里实现，那么把它们抽象出来，做成一个接口规范。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中，有些接口内部没有声明任何方法，也就是说，实现这些接口的类不需要重写任何方法，这些没有任何方法声明的接口又被叫做标识接口，标识接口对实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用，用来表明实现它的类属于一个特定的类型。这个标签类似于汽车的标志图标，每当人们看到一个汽车的标志图标时，就能知道这款车的品牌。Java库中已经存在的标识接口有Cloneable 和 serializable 等。在使用时经常用instanceof 来判断实例对象的类型是否实现了一个给定的标识接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一个例子来说明标识接口的作用。例如要开发一款游戏，游戏里面有一个人物专门负责出去寻找有用的材料，假设这个人物只收集矿石和武器，而不会收集垃圾。下面通过标识接口来实现这个功能。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import Java.util.ArrayList;interface Stuff&#123;&#125;// 矿石interface Ore extends Stuff&#123;&#125;// 武器interface Weapon extends Stuff&#123;&#125;// 垃圾interface Rubblish extends Stuff&#123;&#125;// 金矿class Gold implements Ore&#123; public String toString() &#123; return \"Gold\"; &#125;&#125;// 铜矿class Copper implements Ore&#123; public String toString() &#123; return \"Copper\"; &#125;&#125;// 抢class Gun implements Weapon&#123; public String toString() &#123; return \"Gun\"; &#125;&#125;// 榴弹class Grenade implements Weapon&#123; public String toString() &#123; return \"Grenade\"; &#125;&#125;// 石头class Stone implements Rubblish&#123; public String toString() &#123; return \"Stone\"; &#125;&#125;public class Test&#123; public static ArrayList&lt;Stuff&gt; collectStuff(Stuff[] s) &#123; ArrayList&lt;Stuff&gt; al = new ArrayList&lt;Stuff&gt;(); for(int i = 0;i&lt;s.length;i++) &#123; if(!(s[i] instanceof Rubblish)) // 如果不是垃圾 al.add(s[i]); &#125; return al; &#125;&#125;public stati void main(String[] args)&#123; Stuff[] s = &#123;new Gold(),new Copper(),new Gun(),new Grenade(),new Stone()&#125;; ArrayList&lt;Stuff&gt; al = collectStuff(s); for(int i = 0;i&lt;al.size();i++) &#123; System.out.println(al.get(i)); &#125;&#125; 运行结果为：GoldCopperGunGrenade &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上例中，设计了三个接口：Ore 、Weapon 和 Rubbish 分别代表矿石、武器和垃圾，只要是实现Ore 或 Weapon 的类，游戏中的角色都会认为这是有用的材料，例如Gold、Copper、Gun、Grenade，因此会收集；只要是实现Rubbish 的类，都会被认为是无用的东西，例如Stone，因此不会收集。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"什么是构造函数","date":"2017-12-31T01:20:13.000Z","path":"2017/12/31/什么是构造函数/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数是一种特殊的函数，用来在对象实例化时初始化对象的成员变量。在Java语言中，构造函数具有以下特点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）构造函数必须与类的名字相同，并且不能有返回值（也不能为void）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）每个类可以有多个构造函数。当开发人员没有提供构造函数时，编译器在把源代码编译成字节码的过程中会提供一个没有参数默认的构造函数，但构造函数不会执行任何代码，如果开发人员提供了构造函数，那么编译器就不会再创建默认的构造函数了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）构造函数可以有0个、1个或1个以上的参数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（4）构造函数总是伴随着 new 操作一起调用，且不能由程序的编写者直接调用，必须要由系统调用。构造函数在对象实例化时会被自动调用，且只运行一次；而普通的方法是在程序执行到它是被调用，且可以被重复调用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（5）构造函数的主要作用是完成对象的初始化工作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（6）构造函数不能被继承，因此，它不能被覆盖，但是构造函数能够被重载，可以使用不同的参数个数或参数类型来定义多个构造函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（7）子类可以通过 super 关键字来显式地调用父类的构造函数，当父类没有提供无参数的构造函数时，子类的构造函数中必须显式地调用父类的构造函数。反之不用，这种情况下编译器会默认调用父类的无参构造函数。当有父类时，在实例化对象时会先执行父类的构造函数，然后执行子类的构造函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（8）默认构造函数的修饰符只跟当前类的修饰符有关（如，若一个类被定义为public，那么它的构造函数就是public）。 引申：普通方法可以与构造函数有相同的方法名，相当于方法的重载。例如：123456789101112131415public class Test&#123; public Test() &#123; System.out.println(\"Test 构造方法\"); &#125; public void Test() &#123; System.out.println(\"Test 普通方法\"); &#125; public static void main(String[] args) &#123; Test a = new Test() //调用构造方法 a.Test(); //调用Test（）普通方法 &#125;&#125; 程序运行结果为： Test 构造方法Test 普通方法","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"一个java文件中是否可以定义多个类","date":"2017-12-30T17:53:43.000Z","path":"2017/12/31/一个java文件中是否可以定义多个类/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个java文件中可以定义多个类，但是最多只有一个类被public修饰，并且这个类的类名与文件名必须相同，若这个文件中没有public的类，则文件名随便是一个类的名字即可。余姚注意的是，当用javac指令编译有多个类的Java文件时，它会给每一个类生成一个对应的.class 文件，如d定义D.java文件： 12345678910111213class B&#123; public void print() &#123; System.out.println(\"B\"); &#125;&#125;public class D extends B&#123; public static void main(String[] a) &#123; B c = new D(); c.print(); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用javac D.java 指令编译上述代码，会生成两个字节码文件：B.class 与 D.class。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"Java中的作用域有哪些","date":"2017-12-30T15:10:43.000Z","path":"2017/12/30/Java中的作用域有哪些/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在计算机程序中，声明在不同地方的变量具有不同的作用域，例如局部变量、全局变量等。在java语言中，作用域是由花括号的位置决定的，它决定了其定义的变量名的可见性与生命周期。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在java语言中，变量的类型主要有三种：成员变量、静态变量和局部变量。类的成员变量的作用范围与类的实例化对象的生命周期的作用相同，当类被实例化时，成员变量就会在内存中分配空间并初始化，直到这个被实例化对象的生命周期结束时，成员变量的生命周期才结束。被static戏水的成员变量被称为静态变量或全局变量，与成员变量不同的是，静态变量不依赖于特定的实例，而是被所有实例所共享，也就是说，只要有一个类被加载，JVM就会给类的静态变量分配存储空间。因此，就可以通过类名和变量名来访问静态变量。局部变量的作用域与可见性为它所在的花括号内。 此外，成员变量而又4种作用域： 作用域与可见性 当前类 同一package 子类 其他package public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × （1） public。表明该成员变量或方法对所有类或所有对象都是可见的，所有类或对象都可以直接访问。（2） protected。对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。（3） default。表明该成员变量或方法只有自己和与其位于同一包内的类可见。若父类与子类在同一包内，则子类对父类的default成员变量或方法都有访问权限；反之，没有。（4） private。表明该成员变量或方法是私有的，只有当前类对其具有访问权限，除此之外的其他类或者对象都没有访问权限。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，这些修饰符只能修饰成员变量，不能用来修饰局部变量。private 与 protected 不能用来修饰类（只有public、abstract或final 能用来修饰类）。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"Java程序初始化的顺序是怎样的","date":"2017-12-30T14:26:43.000Z","path":"2017/12/30/Java程序初始化的顺序是怎样的/","text":"在java语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，当所有成员完成初始化后，才会调用对象所在类的构造函数创建对象。 Java程序的初始化一般遵循3个原则（优先级依次递减）： （1）静态对象（变量）优于非静态对象（变量）的初始化，其中，静态对象（变量）只初始化一次，非静态对象（变量）可能会初始化多次。（2）父类优先于子类进行初始化。（3）按照成员变量的定义顺序进行初始化。即使变量定义散布于方法定义之中，他们依然在任何方法（包括构造函数）被调用之前先初始化。 Java程序初始化工作可以在许多不同的代码块中来完成（例如静态代码块，构造函数等），它们执行的顺序如下：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。 实例： 1234567891011121314151617181920212223242526272829class A&#123; static &#123; System.out.println(\"A staic block\"); &#125; &#123; System.out.println(\"A block\"); &#125; public A()&#123; System.out.println(\"A constructor\"); &#125; &#125; class B extends A&#123; static &#123; System.out.println(\"B staic block\"); &#125; &#123; System.out.println(\"B block\"); &#125; public B()&#123; System.out.println(\"B constructor\"); &#125; &#125; public class staticTest &#123; public static void main(String[] args)&#123; System.out.println(\"hello world\"); &#125; &#125; 运行结果：A staic blockB staic blockA blockA constructorB blockB constructorhello world","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"如何实现在main()方法执行前输出“Hello World”","date":"2017-12-30T09:26:43.000Z","path":"2017/12/30/如何实现在main()方法执行前输出“Hello World”/","text":"我们都知道，在java语言中，main()方法是整个程序的入口，程序在运行时最先加载的是main()方法，但是这并不意味着main()方法就是程序运行时第一个被执行的模块。 在java语言中，有一个叫静态块的东西，它可以在类被加载时就会被调用，这也就意味着它可以在main()方法执行前执行，利用静态代码块实现在主函数之前输出hello world如下代码： public class Test{ static{ System.out.println(\"Hello Word!\"); } public static void main(String[] args) { System.out.println(\"Hello Word2!\"); } } 程序运行结果为：Hello Word!Hello Word2! 由于静态块不管顺序如何，都会在main（）方法执行之前执行，因此，下面的代码的执行结果与上面的相同 public class Test{ public static void main(String[] args) { System.out.println(\"Hello Word2!\"); } static{ System.out.println(\"Hello Word!\"); } }","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"为什么需要public static void main ( String[] args) 方法","date":"2017-12-30T08:50:43.000Z","path":"2017/12/30/为什么需要public static void main ( String[] args) 方法/","text":"public static void main ( String[] args)方法为java程序的入口方法，JVM在运行程序时，会首先查找main()方法。其中public是权限修饰符，表明任何类或对象都可以访问这个方法，static表明是静态方法，即方法中的代码是存储在静态存储区的，只要类被加载后，就可以使用该方法，不需要通过实例化来访问，可直接通过类名.main()直接访问，JVM在启动时就是按照上诉方法的签名（必须有public和static修饰，返回值为void，且方法参数为字符串数组）来查找方法的入口地址，若找到就执行，找不到就会报错。void表明方法没有返回值，main是JVM识别的特殊方法名，是程序的入口方法。字符串数组参数args为开发人员在命令行状态下与程序交互提供了一种手段。 引申1.main()方法是否还有其他可用的定义格式？（ 1 ） 由于public 与 static 没有先后顺序关系，因此下面的定义也是合理的。 static public void main(String [] srgs)（ 2 ） 也可以把main() 方法定义为final。 public static final void main ( String[] args)（ 3 ） 也可以用synchronized 来修饰main() 方法。 public static synchronized void main ( String[] args) 总之不管哪种定义方式，都必须保证 main() 方法的返回值为void，并有static 与 public 关键字修饰。同时由于main()方法为程序入口方法，因此不能用abstract 关键字来修饰。 2. 同一个.java文件中是否可以有多个main()方法? 虽然每个类中都可以定义main（）方法，但是只有与文件名相同的用public修饰的类中的main（）方法才能作为整个程序的入口方法。如：创建了一个名为Test.java 的文件。 123456789101112 class T&#123; public static void main(String[] args) &#123; System.out.println(\"T main\"); &#125; &#125;public class Test&#123; public static void main(String[] args) &#123; System.out.println(\"Test main\"); &#125; &#125; 程序的运行结果为：Test main","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"Java与C/C++有什么异同","date":"2017-12-30T08:13:43.000Z","path":"2017/12/30/Java与C++有什么异同/","text":"Java与C/C++有什么异同Java与 C/C++ 都是面向对象的语言，都使用了面向对象思想，二者都有很好的可重用性。不同点如下： （1） Java为解释性语言，运行的过程为：源码经过Java编译器编译成字节码，然后由JVM解释运行。而C/C++为编译型语言，源码经过编译和链接后生成可运行的二进制代码。因此，Java的运行速度比C/C++慢，可是Java能够跨平台运行，而C/C++不能。 （2） Java为纯面向对象语言，全部的代码（包含函数、变量等）必须在类中来实现，除基本数据类型（包含int、float等）以外，全部的类型都是类。此外，Java语言中不存在全局变量或全局函数，而C++兼具面向过程和面向过程编程的特点，能够定义全局变量和全局函数。 （3） 与C/C++语言相比，Java语言中没有指针的概念，有效防止了C/C++语言中操作指针可能引起的系统问题，使得程序变得更加安全。 （4） 与C++语言相比，Java语言不支持多重继承，可是Java语言引入了接口的概念，能够同一时候实现多个接口，因为接口也具有多态的特性，因此在Java语言中能够通过实现多个接口来实现与C++语言中多重继承相似的目的。 （5） 在C++语言中，须要开发者去管理对内存的分配（包含申请与释放），而Java语言提供了垃圾回收器来实现垃圾的自己主动回收，不须要程序显式地管理内存的分配。在C++语言中，通常都会把释放资源的代码放到析构函数中，而Java语言中没有析构函数的概念，可是引入了一个finalize()方法，当垃圾回收器将要释放无用对象的内存时，会首先调用该对象的finalize()方法，因此，开发者不须要关心也不须要知道对象所占的内存空间在何时会被释放。 （6） C++语言支持运算符重载，而Java语言不支持运算符重载。C++语言支持预处理，而Java语言没有预处理器，尽管不支持预处理功能（包含头文件、宏定义等），但它提供的import机制与C++中的预处理器功能相似。C++支持缺省函数參数，而Java不支持缺省函数參数。C/C++支持goto语句，而Java不提供goto语句（但Java中goto是保留keyword）。C/C++支持自己主动强制类型转换，会导致程序的不安全，而Java不支持自己主动强制类型转换，必须由开发者进行显式地强制类型转换。C/C++中，结构和联合的全部成员均为公有，这往往会导致安全性问题的发生，而Java根本就不包含结构和联合，全部的内容都封装在类里面。 （7） Java具有平台无关性，即对每种数据类型都分配固定长度，比如，int类型总是占领32位，而C/C++却不然，同一个数据类型在不同的平台上会分配不同的字节数。 （8） Java提供对凝视文档的内建支持，所以源码文件也能够包含它们自己的文档。通过一个单独的程序，这些文档信息能够提取出来，并又一次格式化成HTML。 （9） Java包含了一些标准库，用于完毕特定的任务，同一时候这些库简单易用，能够大大缩短开发周期，比如Java提供给了用于訪问数据库的JDBC库，用于实现分布式对象的RMI等标准库。C++则依靠一些非标准的、由其他厂商提供的库。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"Java语言有哪些优点","date":"2017-12-30T07:23:43.000Z","path":"2017/12/30/Java语言有哪些优点/","text":"Java语言有哪些优点具体而言，Java语言具有以下几个方面的优点： ( 1 ) Java为纯面向对象的语言《Java编程思想》提到Java语言是一种“ Everything is sbject ” 的语言，它能够直接反应现实生活中的对象，例如火车、动物等，因此通过它，开发人员编写程序更加容易。 ( 2 ) 平台无关性Java语言可以“一次编译到处运行”。无论是在Windows平台还是Linux、MacOS等其他平台上对Java程序进行编译，编译后在其他平台史昂都可以运行。由于Java为解释型语言，编译器会把Java代码变成“中间代码”，然后在Java虚拟机（Java Virtual Machine,JVM） 上解释执行。由于中间代码与平台无关，因此，Java语言可以很好地跨平台执行，具有很好的可移植性。 ( 3 ) Java提供了很多内置的类库通过这些类库，简化了开发人员的程序设计工作，同时缩短了项目开发时间，例如，Java语言提供了对多线程的支持，提供了对网络通信的支持，最重要的是提供了垃圾回收器，这使得开发人员从对内存的管理中解脱出来。 ( 4 ) 提供了对Web应用开发的支持例如，Applet、Servlet和JSP可以用来开发Web应用程序；Socket、RMI可以用来开发分布式应用程序的类库。 ( 5 ) 具有较好的安全性和健壮性。Java语言经常被用在网络环境中，为了增强程序的安全性，Java语言提供了一个防止恶意攻击的安全机制（数组边界检测和 Bytecode 校验等）。Java的强类型机制、垃圾回收器、异常处理和安全检查机制使得用Java语言编写的程序有很好的健壮性。 ( 6 ) 去除了C++语言中难以理解、容易混淆的特性例如头文件、指针、结构、单元、运算符重载、虚拟基础类、多重继承等，使得程序更加严谨、简洁。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.rxdonny.com/tags/Java基础/"},{"name":"基本概念","slug":"基本概念","permalink":"http://www.rxdonny.com/tags/基本概念/"}]},{"title":"hibernate 与 Spring 的整合","date":"2017-11-22T14:31:06.000Z","path":"2017/11/22/hibernate-与-Spring-的整合/","text":"Hibernate 与 Spring 的整合和配置的一般步骤同样是三拷三配 一、整合 添加hibernate 开发包 HibernateSessionFactory类不要，使用Spring中对应的session工厂 添加spring 开发包 hibernate逆向工程 拷log4j 二、配事务-配三个东西这三个东西基本上是固定的，以后做项目的时候，想偷懒的话可以直接复制。 事务管理器 事务属性 织入 1.事务管理器 设置class时键入hibernate 加提示就出来了 选择org.springframework.orm.hibernate3.HibernateTransactionManager12345&lt;!-- 事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.事务属性1234567&lt;!-- 事务的属性 --&gt; &lt;tx:advice id=\"mytx\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 3.织入12345&lt;!-- 织入 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"mytx\" pointcut=\"execution(* com.service.*.*(..)))\"/&gt; &lt;/aop:config&gt; 做完这些就可以写一个test类进行测试了~~下面附上我整合hibernate和Spring 的所有配置文件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt;&lt;!-- 换上强大的头子 --&gt; &lt;!-- 整合时自动生成的session工厂类 --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 在com.dao下有一个叫UserInfoDAO的类 做逆向工程时会自动生成 GoodsDAO同理 --&gt; &lt;bean id=\"UserinfoDAO\" class=\"com.dao.UserinfoDAO\"&gt; &lt;property name=\"sessionFactory\"&gt; &lt;ref bean=\"sessionFactory\" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"GoodsDAO\" class=\"com.dao.GoodsDAO\"&gt; &lt;property name=\"sessionFactory\"&gt; &lt;ref bean=\"sessionFactory\" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 在com.service下有一个叫UserInfoService的类 --&gt; &lt;!-- 这个地方一般需要程序员手动敲上去 因为Spring并不知道你用它来实现什么业务，你得亲口告诉他 --&gt; &lt;bean id=\"UserInfoService\" class=\"com.service.UserInfoService\"&gt; &lt;property name=\"userinfoDAO\" ref=\"UserinfoDAO\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务的属性 --&gt; &lt;tx:advice id=\"mytx\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 织入 --&gt; &lt;aop:config&gt; &lt;!-- * com.service.*.*(..)表示： 所有返回类型 com.service.所有类.所有方法（所有参数）--&gt; &lt;aop:advisor advice-ref=\"mytx\" pointcut=\"execution(* com.service.*.*(..))\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt;","tags":[{"name":"SSH","slug":"SSH","permalink":"http://www.rxdonny.com/tags/SSH/"}]},{"title":"Spring AOP","date":"2017-11-22T13:23:43.000Z","path":"2017/11/22/Spring-AOP/aa/","text":"什么是 AOPAOP是面向切面编程，也就是说面向某个功能模块编程，典型的应用就是Spring的声明式事务，Spring的AOP事务解析；至于概念，我上知乎度了一下，解释得蛮清楚的，这里就直接贴个链接。(链接：https://www.zhihu.com/question/24863332/answer/48376158)在以前的事务管理是要融合在逻辑代码中的，在逻辑代码中决定事务是否提交或者回滚，这样很容易造成代码难以维护，代码冗余但是使用spring的声明式事务后，只需要在数据库处理方法上注解事务，就可以对操作进行管理，事务的设置和逻辑代码分开，容易维护。至于有什么作用，自然就是降低代码的耦合度。 如何使用 Spring AOP 可以通过配置文件或者编程的方式来使用Spring AOP 配置时通过xml文件来进行，方式有很多种，我用来配置 1234567891011121314151617181920212223242526272829303132333435363738 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt;&lt;!-- 换头子 --&gt; &lt;bean id=\"DepDAO\" class=\"com.dao.DepDAO\"&gt;&lt;/bean&gt;&lt;!-- 手动添加 service bean --&gt; &lt;bean id=\"DepService\" class=\"com.service.DepService\"&gt; &lt;property name=\"depDAO\" ref=\"DepDAO\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 添加自己写的事务类 --&gt; &lt;bean id=\"MyTransaction\" class=\"com.transaction.MyTransaction\"&gt;&lt;/bean&gt; &lt;!-- 织入 :将次要业务织入主要业务--&gt; &lt;aop:config&gt; &lt;!-- ref 与上面的id要保持一致 --&gt; &lt;aop:aspect ref=\"MyTransaction\"&gt;&lt;!-- ref 填要织入的东西 --&gt; &lt;!-- before 在 pointcut 之前执行begin方法 即为真实状态下的开启事务 --&gt; &lt;aop:before method=\"begin\" pointcut=\"execution(* com.service.*.*(..))\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;aop:config&gt; &lt;!-- after 在 pointcut 之前执行commit方法 即为真实状态下的提交事务 --&gt; &lt;aop:aspect ref=\"MyTransaction\"&gt; &lt;aop:after method=\"commit\" pointcut=\"execution(* com.service.*.*(..))\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 解释” com.service..*(..) “ ：任意返回类型 com.service包下的所有类的所有方法的所有参数即，程序会自动给 com.service 包下的所有类提供事务,正常使用Spring做项目是就不需要手动开启和提交事务，如果业务比较多的话会减少不少代码。","tags":[{"name":"spring","slug":"spring","permalink":"http://www.rxdonny.com/tags/spring/"}]},{"title":"Spring AOP","date":"2017-11-22T13:23:43.000Z","path":"2017/11/22/Spring-AOP/","text":"什么是 AOPAOP是面向切面编程，也就是说面向某个功能模块编程，典型的应用就是Spring的声明式事务，Spring的AOP事务解析；至于概念，我上知乎度了一下，解释得蛮清楚的，这里就直接贴个链接。(链接：https://www.zhihu.com/question/24863332/answer/48376158)在以前的事务管理是要融合在逻辑代码中的，在逻辑代码中决定事务是否提交或者回滚，这样很容易造成代码难以维护，代码冗余但是使用spring的声明式事务后，只需要在数据库处理方法上注解事务，就可以对操作进行管理，事务的设置和逻辑代码分开，容易维护。至于有什么作用，自然就是降低代码的耦合度。 如何使用 Spring AOP 可以通过配置文件或者编程的方式来使用Spring AOP 配置时通过xml文件来进行，方式有很多种，我用来配置 1234567891011121314151617181920212223242526272829303132333435363738 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt;&lt;!-- 换头子 --&gt; &lt;bean id=\"DepDAO\" class=\"com.dao.DepDAO\"&gt;&lt;/bean&gt;&lt;!-- 手动添加 service bean --&gt; &lt;bean id=\"DepService\" class=\"com.service.DepService\"&gt; &lt;property name=\"depDAO\" ref=\"DepDAO\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 添加自己写的事务类 --&gt; &lt;bean id=\"MyTransaction\" class=\"com.transaction.MyTransaction\"&gt;&lt;/bean&gt; &lt;!-- 织入 :将次要业务织入主要业务--&gt; &lt;aop:config&gt; &lt;!-- ref 与上面的id要保持一致 --&gt; &lt;aop:aspect ref=\"MyTransaction\"&gt;&lt;!-- ref 填要织入的东西 --&gt; &lt;!-- before 在 pointcut 之前执行begin方法 即为真实状态下的开启事务 --&gt; &lt;aop:before method=\"begin\" pointcut=\"execution(* com.service.*.*(..))\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;aop:config&gt; &lt;!-- after 在 pointcut 之前执行commit方法 即为真实状态下的提交事务 --&gt; &lt;aop:aspect ref=\"MyTransaction\"&gt; &lt;aop:after method=\"commit\" pointcut=\"execution(* com.service.*.*(..))\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 解释” com.service..*(..) “ ：任意返回类型 com.service包下的所有类的所有方法的所有参数即，程序会自动给 com.service 包下的所有类提供事务,正常使用Spring做项目是就不需要手动开启和提交事务，如果业务比较多的话会减少不少代码。","tags":[{"name":"spring","slug":"spring","permalink":"http://www.rxdonny.com/tags/spring/"}]},{"title":"Mybatis-基本操作之动态sql","date":"2017-11-18T15:34:59.000Z","path":"2017/11/18/Mybatis-基本操作之动态sql/","text":"以一张学生表student(id,sname,sage,sex)为例,对应pojo类是Student.java,属性名与表的字段名一致。环境搭建无误后就可以执行以下操作： 1、动态sql之where首先在pojo的配置文件 studentMap.xml 中添加如下代码 1234567891011121314151617&lt;!-- 动态sql之where --&gt; &lt;select id=\"dynamicWhere\" parameterType=\"map\" resultType=\"stu\"&gt; select &lt;include refid=\"fields\"/&gt; from Student &lt;where&gt; &lt;if test=\"sname!=null\"&gt; sname like concat(#&#123;sname&#125;,'%') &lt;/if&gt; &lt;if test=\"sageMin!=null\"&gt; and sage&gt;=#&#123;sageMin&#125; &lt;/if&gt; &lt;if test=\"sageMax!=null\"&gt; and sage &amp;lt;=#&#123;sageMax&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 编写测试类：FindStudentByDynamicWhere.java 1234567891011121314151617181920212223242526272829303132333435363738package com.test;import java.io.InputStream;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.pojo.Student;public class FindStudentByDynamicWhere &#123; public static void main(String[] args) &#123; //1.获取总的配置文件 --有很多种读法 InputStream is = FindStudentByDynamicWhere.class.getResourceAsStream(\"/SqlMapConfig.xml\"); //2.创建session工厂 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, \"MySQL\"); //3.开启session SqlSession session = sessionFactory.openSession(); //4.增删改查 Map map = new HashMap(); map.put(\"sname\", \"我\"); map.put(\"sageMin\",\"1980-02-11 10:11:12\"); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDAO.dynamicWhere\",map); for (Student student : list) &#123; System.out.println(student.getId()+\"\\t\"+student.getSname()); &#125; //5.关闭事务 session.commit(); //6.关闭session session.close(); &#125;&#125; 2、动态sql之update首先在pojo的配置文件 studentMap.xml 中添加如下代码 1234567891011121314151617&lt;!-- 动态sql之update --&gt; &lt;update id=\"updateById\" parameterType=\"stu\"&gt; update student &lt;set&gt; &lt;if test=\"sname!=null\"&gt; sname=#&#123;sname&#125;, &lt;/if&gt; &lt;if test=\"sex!=null\"&gt; sex=#&#123;sex&#125;, &lt;/if&gt; &lt;if test=\"sage!=null\"&gt; sage=#&#123;sage&#125;, &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; 编写测试类：FindStudentByDynamicUpdate.java 1234567891011121314151617181920212223242526272829303132333435363738package com.test;import java.io.InputStream;import java.sql.Timestamp;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.pojo.Student;public class FindStudentByDynamicUpdate &#123; public static void main(String[] args) &#123; //1.获取总的配置文件 --有很多种读法 InputStream is = FindStudentByDynamicUpdate.class.getResourceAsStream(\"/SqlMapConfig.xml\"); //2.创建session工厂 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, \"MySQL\"); //3.开启session SqlSession session = sessionFactory.openSession(); //4.增删改查 Student stu = new Student(); stu.setSname(\"小5\"); stu.setSex(1); stu.setId(10); stu.setSage(Timestamp.valueOf(\"1990-02-11 10:11:12\")); int n = session.update(\"com.dao.StudentDAO.updateByid\", stu); if(n!=0) System.out.println(\"ok!\"+'\\t'+stu.getId()); //5.关闭事务 session.commit(); //6.关闭session session.close(); &#125;&#125; 3、其他配置小技巧(1)、不小心将pojo类的属性名跟表的字段名设置得不一致————在pojo的配置文件中用进行一一映射如：1234567&lt;!-- 当表的字段名跟pojo的属性名不一致时可以在这里映射一一对应关系 --&gt; &lt;resultMap type=\"stu\" id=\"stuMapper\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"sname\" column=\"sname\"/&gt; &lt;result property=\"sage\" column=\"sage\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;/resultMap&gt; (2)、sql语句字段太多,增删改麻烦————在pojo的配置文件中用将使用重复度高的字段写在标签内，用$lt;input /&gt;标签导入使用如：123456789&lt;!-- 使用&lt;sql&gt;&lt;/sql&gt;标签预先编辑常用的sql字段，也方便增删改 --&gt;&lt;sql id=\"fields\"&gt; id,sname,sex,sage &lt;/sql&gt; &lt;!-- 使用 --&gt; &lt;select id=\"fenye\" resultType=\"stu\" parameterType=\"map\"&gt; select &lt;include refid=\"fields\"/&gt; from student limit #&#123;x&#125;,#&#123;y&#125; &lt;/select&gt;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.rxdonny.com/tags/Mybatis/"}]},{"title":"Mybatis-基本操作之增删改查","date":"2017-11-18T13:38:40.000Z","path":"2017/11/18/Mybatis-基本操作之增删改查/","text":"以一张学生表student(id,sname,sage,sex)为例,对应pojo类是Student.java,属性名与表的字段名一致。环境搭建无误后就可以执行以下操作： 1、根据主键查学生首先在pojo的配置文件 studentMap.xml 中添加如下代码12345678&lt;!-- 根据主键查找 --&gt; &lt;!-- id:方法名 parameterType：参数类型 --&gt; &lt;!-- resultType：返回的结果的类型 如果是通过&lt;resultMap&gt; 建立映射关系的用 resultMap=\"上面配的id\"--&gt; &lt;!-- 当传递的参数只有一个时 &#123; &#125;中就填value --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.pojo.Student\"&gt; select &lt;include refid=\"fields\"/&gt; from student where id=$&#123;value&#125; &lt;/select&gt; 编写测试类 FindStudentById.java 12345678910111213141516171819202122232425262728293031323334package com.test;import java.io.InputStream;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.pojo.Student;public class FindStudentById &#123; public static void main(String[] args) &#123; //1.获取总的配置文件 --有很多种读法 InputStream is = FindStudentById.class.getResourceAsStream(\"/SqlMapConfig.xml\"); //2.创建session工厂 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, \"MySQL\"); //3.开启session SqlSession session = sessionFactory.openSession(); //4.增删改查 Student student = new Student(); student = (Student) session.selectOne(\"com.dao.StudentDAO.findByid\",5); if(student!=null) &#123; System.out.println(student.getId()+\"\\t\"+student.getSname()); &#125; //5.关闭事务 session.commit(); //6.关闭session session.close(); &#125;&#125; 2、新增学生首先在pojo的配置文件 studentMap.xml 中添加如下代码 123456789101112&lt;!-- 新增学生 ——主键自动增长 --&gt; &lt;!-- keyProperty: 若要得到新增的id 就要设置 --&gt; &lt;insert keyProperty=\"id\" useGeneratedKeys=\"true\" id=\"add\" parameterType=\"com.pojo.Student\"&gt; &lt;!-- 不是自动增长 &lt;selectKey keyProperty=\"id\"&gt; select &lt;/selectKey&gt; --&gt; &lt;!-- 增删改 不需要设置 resultType 因为其返回的是受影响的行数 都是int型 不需要配置--&gt; insert into student(sname,sex,sage) values(#&#123;sname&#125;,#&#123;sex&#125;,#&#123;sage&#125;) &lt;/insert&gt; 编写测试类 InsertStudent.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import java.io.InputStream;import java.io.Reader;import java.sql.Timestamp;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.pojo.Student;public class InsertStudent &#123; public static void main(String[] args) &#123; //1.读取总的配置文件 InputStream is = InsertStudent.class.getResourceAsStream(\"/SqlMapConfig.xml\"); //Reader reader = //2.创建session工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is,\"MySQL\"); //3.打开session SqlSession session = factory.openSession(); //4.增删改查CRUD Student stu = new Student(); stu.setSname(\"小3\"); stu.setSex(1); stu.setSage(Timestamp.valueOf(\"1980-02-11 10:11:12\")); int n = session.insert(\"com.dao.StudentDAO.add\", stu); System.out.println(stu.getId());//需要配置映射文件 //5.提交事务 session.commit(); //6.关闭session session.close(); &#125;&#125; 3、分页查询（逻辑分页、物理分页）首先在pojo的配置文件 studentMap.xml 中添加如下两端代码， 123456789&lt;!-- 查所有学生 ：逻辑分页 从第一页开始查 --&gt; &lt;select id=\"getAll\" resultType=\"stu\"&gt; select &lt;include refid=\"fields\"/&gt; from student &lt;/select&gt; &lt;!-- 查所有学生 ：物理分页 --&gt; &lt;select id=\"fenye\" resultType=\"stu\" parameterType=\"map\"&gt; select &lt;include refid=\"fields\"/&gt; from student limit #&#123;x&#125;,#&#123;y&#125; &lt;/select&gt; (1)、逻辑分页测试类：FindStudentByLogic.java12345678910111213141516171819202122232425262728293031323334353637package com.test;import java.io.InputStream;import java.util.List;import org.apache.ibatis.session.RowBounds;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.pojo.Student;public class FindStudentByLogic &#123; public static void main(String[] args) &#123; //1.获取总的配置文件 --有很多种读法 InputStream is = FindStudentByLogic.class.getResourceAsStream(\"/SqlMapConfig.xml\"); //2.创建session工厂 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, \"MySQL\"); //3.开启session SqlSession session = sessionFactory.openSession(); //4.增删改查 RowBounds bounds = new RowBounds(5,5); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDAO.getall\",null,bounds); for (Student student : list) &#123; System.out.println(student.getId()+\"\\t\"+student.getSname()); &#125; //5.关闭事务 session.commit(); //6.关闭session session.close(); &#125;&#125; (2)、物理分页测试类：FindStudentByfenye.java 1234567891011121314151617181920212223242526272829303132333435363738package com.test;import java.io.InputStream;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.pojo.Student;public class FindStudentByfenye &#123; public static void main(String[] args) &#123; //1.获取总的配置文件 --有很多种读法 InputStream is = FindStudentByfenye.class.getResourceAsStream(\"/SqlMapConfig.xml\"); //2.创建session工厂 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is, \"MySQL\"); //3.开启session SqlSession session = sessionFactory.openSession(); //4.增删改查 Map map = new HashMap(); map.put(\"x\", 3); map.put(\"y\", 4); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDAO.fenye\",map); for (Student student : list) &#123; System.out.println(student.getId()+\"\\t\"+student.getSname()); &#125; //5.关闭事务 session.commit(); //6.关闭session session.close(); &#125;&#125;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.rxdonny.com/tags/Mybatis/"}]},{"title":"Mybatis-环境搭配","date":"2017-11-18T13:31:40.000Z","path":"2017/11/18/Mybatis/","text":"一、MyBatis简介 MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML 或注解用于配置和原始映射，将接口和 Java 的 pojo 映射成数据库中的记录。 每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactoryBuilder可以从一个xml配置文件或者一个预定义的配置类的实例获得。特点：简单易学灵活解除sql与程序代码的耦合度提供映射标签提供对象关系映射标签，支持对象关系组建维护提供XML标签，支持编写动态sql 二、MyBatis环境搭配mybatis的环境搭配总结起来就是“三拷三配”。首先先创建一个java工程或web工程都可以，然后就可以进行下面的操作了 三拷1、拷mybatis开发包2、拷MySQL驱动包3、拷log4j 三配1、配置pojo，即创建一个pojo类,如Student.java 12345678910111213141516171819202122232425262728293031323334package com.pojo;import java.io.Serializable;import java.sql.Timestamp;public class Student implements Serializable &#123; private int id; private String sname; private int sex; private Timestamp sage; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public Timestamp getSage() &#123; return sage; &#125; public void setSage(Timestamp sage) &#123; this.sage = sage; &#125;&#125; 2、配置pojo的XML映射文件，一个pojo类对应一个pojo配置文件,如：studentMap.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"mybatis-3-mapper.dtd\"&gt; &lt;!-- mybatis-3-mapper.dtd 是官方提供的用于提示代码的文件 已经下载到本地 --&gt;&lt;!-- namespace=\" \"里面统一写dao --&gt;&lt;mapper namespace=\"com.dao.StudentDAO\"&gt; &lt;!-- 根据主键查找 --&gt; &lt;!-- id:方法名 parameterType：参数类型 --&gt; &lt;!-- resultType：返回的结果的类型 如果是通过&lt;resultMap&gt; 建立映射关系的用 resultMap=\"上面配的id\"--&gt; &lt;!-- 当传递的参数只有一个时 &#123; &#125;中就填value --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.pojo.Student\"&gt; select &lt;include refid=\"fields\"/&gt; from student where id=$&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 3、配置总的配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//ibatis.apache.org//DTD Config 3.0//EN\" \"mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"MySQL\"&gt;&lt;!-- 设置环境 并设置默认环境 --&gt; &lt;environment id=\"MySQL\"&gt;&lt;!-- 环境名 配置JDBC的四个参数 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt;&lt;!-- 使用连接池 不使用 UNPOOLED --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/s55\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"admin\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;mappers&gt;&lt;!-- 引入 pojo的配置文件 --&gt; &lt;mapper resource=\"com/pojo/studentMap.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.rxdonny.com/tags/Mybatis/"}]},{"title":"Mybatis-环境搭配","date":"2017-11-18T13:31:40.000Z","path":"2017/11/18/Mybatis-环境搭配/","text":"一、MyBatis简介 MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML 或注解用于配置和原始映射，将接口和 Java 的 pojo 映射成数据库中的记录。 每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactoryBuilder可以从一个xml配置文件或者一个预定义的配置类的实例获得。特点：简单易学灵活解除sql与程序代码的耦合度提供映射标签提供对象关系映射标签，支持对象关系组建维护提供XML标签，支持编写动态sql 二、MyBatis环境搭配mybatis的环境搭配总结起来就是“三拷三配”。首先先创建一个java工程或web工程都可以，然后就可以进行下面的操作了 三拷1、拷mybatis开发包2、拷MySQL驱动包3、拷log4j 三配1、配置pojo，即创建一个pojo类,如Student.java 12345678910111213141516171819202122232425262728293031323334package com.pojo;import java.io.Serializable;import java.sql.Timestamp;public class Student implements Serializable &#123; private int id; private String sname; private int sex; private Timestamp sage; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public Timestamp getSage() &#123; return sage; &#125; public void setSage(Timestamp sage) &#123; this.sage = sage; &#125;&#125; 2、配置pojo的XML映射文件，一个pojo类对应一个pojo配置文件,如：studentMap.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"mybatis-3-mapper.dtd\"&gt; &lt;!-- mybatis-3-mapper.dtd 是官方提供的用于提示代码的文件 已经下载到本地 --&gt;&lt;!-- namespace=\" \"里面统一写dao --&gt;&lt;mapper namespace=\"com.dao.StudentDAO\"&gt; &lt;!-- 根据主键查找 --&gt; &lt;!-- id:方法名 parameterType：参数类型 --&gt; &lt;!-- resultType：返回的结果的类型 如果是通过&lt;resultMap&gt; 建立映射关系的用 resultMap=\"上面配的id\"--&gt; &lt;!-- 当传递的参数只有一个时 &#123; &#125;中就填value --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.pojo.Student\"&gt; select &lt;include refid=\"fields\"/&gt; from student where id=$&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 3、配置总的配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//ibatis.apache.org//DTD Config 3.0//EN\" \"mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"MySQL\"&gt;&lt;!-- 设置环境 并设置默认环境 --&gt; &lt;environment id=\"MySQL\"&gt;&lt;!-- 环境名 配置JDBC的四个参数 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt;&lt;!-- 使用连接池 不使用 UNPOOLED --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/s55\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"admin\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;mappers&gt;&lt;!-- 引入 pojo的配置文件 --&gt; &lt;mapper resource=\"com/pojo/studentMap.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.rxdonny.com/tags/Mybatis/"}]},{"title":"spring框架中xml文件常用的属性配置","date":"2017-11-14T14:59:10.000Z","path":"2017/11/14/spring框架中xml文件常用的属性配置/","text":"在spring框架中，很多类的对象是不需要我们手动去new的，在spring中通常是将要用到的类即有可能需要实例化对象的类对在application.xml文件中进行配置，那么就要问了，怎么预测那些类要用呢？那就得看你自己了，是在不行就全部都写上去嘛，反正我是这么想的。哈哈！ 下面看看application.xml文件中常用的属性配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;!-- 以上就是添加spring开发包后换的一个头子，作用就是功能更强大些，就先这么理解 --&gt; &lt;!-- 常用的属性配置 --&gt; &lt;bean id=\"Student\" class=\"com.pojo.Student\"&gt; &lt;!-- 常规属性 --&gt; &lt;property name=\"stuid\" value=\"3\"&gt;&lt;/property&gt; &lt;property name=\"stuname\" value=\"李四\"&gt;&lt;/property&gt; &lt;!-- 数组的配置 --&gt; &lt;property name=\"loves\"&gt; &lt;list&gt; &lt;value&gt;吃&lt;/value&gt; &lt;value&gt;喝&lt;/value&gt; &lt;value&gt;玩&lt;/value&gt; &lt;value&gt;乐&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map集合的配置 --&gt; &lt;property name=\"others\"&gt; &lt;map&gt; &lt;entry key=\"age\" value=\"18\"&gt;&lt;/entry&gt; &lt;entry key=\"height\" value=\"180\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"StudentDAO\" class=\"com.dao.StudentDAO\"&gt;&lt;/bean&gt; &lt;bean id=\"StudentService\" class=\"com.service.StudentService\"&gt; &lt;!-- 属性值关键字 value 和 ref 的区别 --&gt; &lt;property name=\"studentDAO\" ref=\"StudentDAO\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 这里对44行注释部分进行说明；在对示例对象进行初始化的时候，初始化的内容用value和用ref的情况如下： value： 为属性设置固定值时用value；如：123&lt;property name=&quot;stuid&quot; value=&quot;3&quot;&gt;&lt;/property&gt;&lt;property name=&quot;stuname&quot; value=&quot;李四&quot;&gt;&lt;/property&gt; ref： 当属性本身就是一个bean（标签）的时候用 ref如：12345&lt;bean id=&quot;StudentDAO&quot; class=&quot;com.dao.StudentDAO&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;StudentService&quot; class=&quot;com.service.StudentService&quot;&gt; &lt;property name=&quot;studentDAO&quot; ref=&quot;StudentDAO&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ref里面的内容要跟上面一个bean的id的内容一致","tags":[{"name":"SSH","slug":"SSH","permalink":"http://www.rxdonny.com/tags/SSH/"}]},{"title":"SAXReader解析xml文档","date":"2017-11-13T14:26:17.000Z","path":"2017/11/13/SAXReader解析xml文档/","text":"解析前准备导入dom4j-full.jar包dom4j是一个类似于jdom的java xml API，用来读写XML文件。 举例： bean.xml内容编写一个名为 bean.xml 的xml文件。123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans&gt; &lt;bean id=\"Student\" name=\"com.pojo.Student\" &gt;&lt;/bean&gt;&lt;/beans&gt; 解析假设有一个Student类在com.pojo 包下。getInstance(String id)方法：根据传递过来的id解析xml文件找到对应的标签,再获取该标签中name属性的值（com.pojo.Student 一个类的全类名），通过反射得到Student类，返回它。 12345678910111213141516171819202122232425262728293031323334package com.spring;import java.io.FileInputStream;import java.io.FileNotFoundException;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class ApplicationContext &#123; public static Object getInstance(String id) throws FileNotFoundException, DocumentException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123; // 解析自己写的bean.xml SAXReader reader = new SAXReader(); // 读取xml文件 Document document = reader.read(new FileInputStream(\"src/bean.xml\")); // 根据id得到 bean标签 元素 Element element = (Element) document.selectSingleNode(\"beans/bean[@id='\" + id + \"']\"); // 根据元素去属性值 -- 是一个类的全类名 String name = element.attributeValue(\"name\"); // 反射到对应的类 Class c = Class.forName(name); // 返回这个类的一个示例 新new的 return c.newInstance(); &#125;&#125;","tags":[{"name":"xml","slug":"xml","permalink":"http://www.rxdonny.com/tags/xml/"}]},{"title":"学习编写博客","date":"2017-11-11T08:38:45.000Z","path":"2017/11/11/learn/","text":"标题： 是几级标题就用几个 # 符号，每增加一个 # 表示更深入一个层次的容，总共有六级标题。标准的Markdown语法需要在符号后面多加一个空格，建议加上。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 列表：无序列表 1 2 3 有序列表 1 2 3编写列表时，文本部分与前面的标识符有一个空格 引用第一种:通过在文字开头添加“&gt;”表示块注释，快捷键使用 Ctrl + Q 例如； 为中华之崛起而读书 第二种: 使用tab键或者四个空格要注意符号与文本间的空格 图片与链接图片：![图片名称](图片地址) 图片名称可以是本地路径，也可以是图片网址 网址：[描述](网址) 可以使用快捷键 Ctrl + L 快速设置； 插入链接示例：[点我去百度](http://www.baidu.com) 点我去百度 插入图片 粗体与斜体粗体：用来两个 * 包含一段文本就是粗体 你看我是粗体 斜体：用一个 * 包含文本 斜体来了 值得注意的是：文本与符号之间不能有空格 删除线在需要设置删除线的文字两侧加两个波浪线 ~~ 夹起来，可以表示 删除文字； 分割线加三个 - 或三个 * 代码框第一种:引入单行代码出现一个代码框，需要使用键盘左上角的ESC键下面的反单引号夹在文字两侧，两侧各一个就行。 例如：`Hellow world！` 显示：Hellow world！ 第二种：多行代码的引入需要在代码段的前后分别使用三个反单引号 说明：用三个 ` 将代码包含起来就行；在开头加上java。显示：1234567891011@Autowiredprivate UserService userService ;//查找所有的用户@RequestMapping(params=\"method=fenye\")public String findall(HttpServletRequest request , HttpServletResponse response)&#123; List&lt;Userinfo&gt; list = userService.fenye(1,2); request.setAttribute(\"list\", list); return \"show.jsp\";//转发 &#125;&#125; 绘制表格|Tables |Are |Cool || -------- |:----------:|----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 显示： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1","tags":[{"name":"入门","slug":"入门","permalink":"http://www.rxdonny.com/tags/入门/"}]}]